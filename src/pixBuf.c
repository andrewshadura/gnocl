/** pixBuf.c
\brief     pixBufs are offscreen drawables.
\author    William J Giddings email: wjgiddings@blueyonder.co.uk
\date      17-Jan-2010
\version   0.9.94
\note      Module generated by gnocl_template_assistant.
\bugs      SVG rotation and composition produce errors.
\history
			06/09/10	composite -completed implementation of all options
			17/08/10	pixbuf commands
							snapshot
							screenshot
            09/04/10    pixbuf command
                            duplicate
            15/03/10    pixbuf command
                            info
            05/03/10
                        pixbuf command
                            setPixel
            02/03/10    pixbuf command
                            get drawable | image
                            render
            26/02/10    pixbuf command
                            subpixbuf
            20/02/10    pixbuf command
                            copy
            16/02/10    pixbuf command
                            draw
            15/02/10    pixbuf commands
                            composite
                            resize
                            scale
            14/02/10    pixbuf commands
                            turn
                            flip
                            rotate
                        commands
                            load

            13/02/10    pixbuf commands
                            save
                            fill
                            class
            12/02/10    commands
                            new
            11/02/10    commands
                            types
                            description <type>
                            license | licence <type>
                            extension <type>
                            scaleble <type>
                            writable <type>
                            fileInfo <fileName>
\todo
        1) Resolve what acolor actually does.
        2) Perform alpha channel operations.
            set, erase, get
**/

/**
\page page_pixbuf gnocl::pixBuf
\htmlinclude pixbuf.html
**/

#include "gnocl.h"
#include "gnocl_logo.h"
#include "gnocl_pointer.h"
#include <string.h>
#include <assert.h>

GdkPixbuf *gnoclGetPixBufFromName ( const char *id, Tcl_Interp *interp );
const char *gnoclGetNameFromPixBuf ( GdkPixbuf *pixbuf );
static guint32 convertRGBtoPixel ( gchar *clr );
static void set_pixel_color ( GdkPixbuf *pixbuf, int x, int y, guchar red, guchar green, guchar blue, guchar alpha );

/* needs to be public to be accessed by gnocl::inventory */
static GHashTable *name2pixbufList;
static const char idPrefix[] = "::gnocl::_PBUF";

/*
canpixbufs be created and modified using standard properties?
*/
static GnoclOption pixBufOptions[] =
{
	{ "-width", GNOCL_BOOL, "width"}, /* 0 */
	{ "-height", GNOCL_OBJ, "height"}, /* 1 */
	{ "-bitsPerSample", GNOCL_OBJ, "bits-per-sample"}, /* 2 */
	{ "-alpha", GNOCL_OBJ, "has-alpha"}, /* 3 */
	{ "-colorspace", GNOCL_OBJ, "colorspace"}, /* 4 */
	{ "-nChannels", GNOCL_OBJ, "n-channels"}, /* 5*/

	/* GtkObject Properties */
	{ "-data", GNOCL_OBJ, "", gnoclOptData },

	{ NULL }
};

static const int aIdx  = 0;
static const int bIdx  = 1;
static const int cIdx  = 2;
static const int dIdx  = 3;
static const int eIdx  = 4;
static const int fIdx  = 5;

void gnoclGetPixBufList ( GList **list )
{
	g_hash_table_foreach ( name2pixbufList, hash_to_list, list );
}

/**
\brief  Rotate a pixbuf through an arbitrary angle (degrees).
\author
\date   15/Feb/2010
\since  0.9.94
\note   Adaption of:
     GdkPixbuf * gdk_pixbuf_rotate(GdkPixbuf *pixbuf, double angle, int acolor)

     The returned image has the same size as the original, but the
     pixbuf envelope is increased to accomodate the rotated original
     (e.g. a 100x100 pixbuf rotated 45 deg. needs a 142x142 pixbuf).

     Pixels added around the rotated image have all RGB values = acolor.   //  v.2.17

     Angle is in degrees. Positive direction is clockwise.
     Pixbuf must have 8 bits per channel and 3 or 4 channels.
     Loss of resolution is about 1/2 pixel.
     Speed is about 18 million pixels/sec. on my 2.67 GHz CPU.             //  v.3.2

     NULL is returned if the function fails for one of the following:
         - pixbuf not 8 bits/channel or < 3 channels
         - unable to create output pixbuf (lack of memory?)

     Algorithm:
         create output pixbuf big enough for rotated input pixbuf
         compute coefficients for affine transform
         loop all output pixels
            get next output pixel (px2,py2)
            convert to input pixel (px1,py1) using affine transform        //  v.3.2
            if outside of pixmap
               output pixel = black
               continue
            for 4 input pixels based at (px0,py0) = (int(px1),int(py1))
               compute overlap (0 to 1) with (px1,py1)
               sum RGB values * overlap
            output aggregate RGB to pixel (px2,py2)
\see    http://kornelix.squarespace.com

    Note: Not really certain what the acolor variable actually does.

**/
static GdkPixbuf * pixbufRotate ( GdkPixbuf *pixbuf1, double angle, int acolor )
{
	/* 3 RGB values, 0-255 each */
	typedef unsigned char  *pixel;

	GdkPixbuf *pixbuf2;
	GdkColorspace color;

	int nch, nbits, alpha;
	int ww1, hh1, rs1, ww2, hh2, rs2;
	int px2, py2, px0, py0;
	pixel ppix1, ppix2, pix0, pix1, pix2, pix3;
	double px1, py1;
	double f0, f1, f2, f3, red, green, blue;
	double a, b, d, e, ww15, hh15, ww25, hh25;
	double pi = 3.141593;

	nch = gdk_pixbuf_get_n_channels ( pixbuf1 );
	nbits = gdk_pixbuf_get_bits_per_sample ( pixbuf1 );

	/* must have 3+ channels (colors) */
	if ( nch < 3 ) return 0;

	/* must be 8 bits per channel */
	if ( nbits != 8 ) return 0;

	/* get input pixbuf1 attributes */
	color = gdk_pixbuf_get_colorspace ( pixbuf1 );
	alpha = gdk_pixbuf_get_has_alpha ( pixbuf1 );
	ww1 = gdk_pixbuf_get_width ( pixbuf1 );
	hh1 = gdk_pixbuf_get_height ( pixbuf1 );
	rs1 = gdk_pixbuf_get_rowstride ( pixbuf1 );

	/* normalize, -180 to +180 */
	while ( angle < -180 ) angle += 360;

	while ( angle > 180 ) angle -= 360;

	/* radians, -pi to +pi */
	angle = angle * pi / 180;

	/*  bugfix 0.01 >> 0.001   v.2.1 */
	if ( fabs ( angle ) < 0.001 )
	{
		/* angle is zero within my precision */
		pixbuf2 = gdk_pixbuf_copy ( pixbuf1 );
		return pixbuf2;
	}

	/* rectangle containing rotated image */
	ww2 = ww1 * fabs ( cos ( angle ) ) + hh1 * fabs ( sin ( angle ) );
	hh2 = ww1 * fabs ( sin ( angle ) ) + hh1 * fabs ( cos ( angle ) );

	/* create output pixbuf2 */
	pixbuf2 = gdk_pixbuf_new ( color, alpha, nbits, ww2, hh2 );

	if ( ! pixbuf2 ) return 0;

	rs2 = gdk_pixbuf_get_rowstride ( pixbuf2 );

	/* input pixel array */
	ppix1 = gdk_pixbuf_get_pixels ( pixbuf1 );

	/* output pixel array */
	ppix2 = gdk_pixbuf_get_pixels ( pixbuf2 );

	ww15 = 0.5 * ww1;
	hh15 = 0.5 * hh1;
	ww25 = 0.5 * ww2;
	hh25 = 0.5 * hh2;

	/* affine transform coefficients   v.3.2 */
	a = cos ( angle );
	b = sin ( angle );
	d = - sin ( angle );
	e = cos ( angle );

	/* loop through output pixels */
	for ( py2 = 0; py2 < hh2; py2++ )
		for ( px2 = 0; px2 < ww2; px2++ )
		{
			/* (px1,py1) = corresponding       v.3.2 */
			px1 = a * ( px2 - ww25 ) + b * ( py2 - hh25 ) + ww15;

			/* point within input pixels */
			py1 = d * ( px2 - ww25 ) + e * ( py2 - hh25 ) + hh15;

			/* pixel containing (px1,py1) */
			px0 = px1;
			py0 = py1;

			/* if outside input pixel array */
			if ( px1 < 0 || px0 >= ww1 - 1 || py1 < 0 || py0 >= hh1 - 1 )
			{
				/* output is acolor    v.2.17 */
				pix2 = ppix2 + py2 * rs2 + px2 * nch;
				pix2[0] = pix2[1] = pix2[2] = acolor;
				continue;
			}

			/* 4 input pixels based at (px0,py0) */
			pix0 = ppix1 + py0 * rs1 + px0 * nch;
			pix1 = pix0 + rs1;
			pix2 = pix0 + nch;
			pix3 = pix0 + rs1 + nch;

			/* overlap of (px1,py1) */
			f0 = ( px0 + 1 - px1 ) * ( py0 + 1 - py1 );

			/* in each of the 4 pixels */
			f1 = ( px0 + 1 - px1 ) * ( py1 - py0 );
			f2 = ( px1 - px0 ) * ( py0 + 1 - py1 );
			f3 = ( px1 - px0 ) * ( py1 - py0 );

			/* sum the weighted inputs */
			red =   f0 * pix0[0] + f1 * pix1[0] + f2 * pix2[0] + f3 * pix3[0];
			green = f0 * pix0[1] + f1 * pix1[1] + f2 * pix2[1] + f3 * pix3[1];
			blue =  f0 * pix0[2] + f1 * pix1[2] + f2 * pix2[2] + f3 * pix3[2];

			/* avoid acolor in image     v.2.17 */
			if ( red == acolor && green == acolor && blue == acolor )
			{
				if ( blue == 0 ) blue = 1;
				else blue--;
			}

			/* output pixel */
			pix2 = ppix2 + py2 * rs2 + px2 * nch;
			pix2[0] = red;
			pix2[1] = green;
			pix2[2] = blue;
		}

	return pixbuf2;
}

/**
\brief
\author     Peter G Baum
\date
\note       From module parseoptions.c
\since      0.9.94
**/
static int getShortValue ( Tcl_Interp *interp, Tcl_Obj *list, int idx, int *p )
{
	int val;
	Tcl_Obj *tp;

	if ( Tcl_ListObjIndex ( interp, list, idx, &tp ) != TCL_OK  )
		return TCL_ERROR;

	if ( Tcl_GetIntFromObj ( NULL, tp, &val ) != TCL_OK )
	{
		double d;

		if ( Tcl_GetDoubleFromObj ( NULL, tp, &d ) != TCL_OK )
		{
			Tcl_AppendResult ( interp,
							   "expected integer or double, but got \"",
							   Tcl_GetString ( tp ), "\"", NULL );
			return TCL_ERROR;
		}

		val = d * 0xFFFF;
	}

	if ( val < .0 || val > 0xFFFF )
	{
		Tcl_SetResult ( interp, "color value must be between 0 and 65535",
						TCL_STATIC );
		return TCL_ERROR;
	}

	*p = val;

	return TCL_OK;
}

/**
\brief
\author     Tadej Borov≈°ak
\date       14/Feb/2010
\note       gdk_color_parse() will only fill red, green and blue elements
             of GdkColor. In order to fill pixel value, you'll need to
             allocate your color using gdk_colormap_alloc_color().
             But event if you do this, pixel value is not what you want
             in this case, since pixel value is only meaningful in context
             of your underlying windowing system.

**/
static guint32 convertRGBtoPixel ( gchar *clr )
{

	GdkColor color;
	guint32 pixel;

	/* Conversion factor from 16-bit color to 8-bit color (0xff / 0xffff) */
	const gdouble f = 0.00389105;

	/* create the colour from the supplied string, added by WJG */
	gdk_color_parse ( clr, &color );

	/* fill with colour */
	pixel = ( ( ( guint ) ( color.red   * f + 0.5 ) ) << 24 ) | /* R */
			( ( ( guint ) ( color.green * f + 0.5 ) ) << 16 ) | /* G */
			( ( ( guint ) ( color.blue  * f + 0.5 ) ) <<  8 ) | /* B */
			( 0xff <<  0 );                                     /* A */

#ifdef DEBUG_PIXBUF
	printf ( "pixel = %d\n", pixel );
#endif
	return pixel;
}


/**
\brief
\author     Peter G Baum
\date
\note       From module parseoptions.c
\since      0.9.94
**/
static int getRGBA ( Tcl_Interp *interp, Tcl_Obj *obj, int *r, int *g, int *b, int *a )
{
	int no;

	if ( Tcl_ListObjLength ( interp, obj, &no ) != TCL_OK  || no < 0 || no > 4 )
	{
		Tcl_SetResult ( interp, "color must be either \"name\" or a list "
						"consisting of \"name alpha\", \"r g b\", or \"r g b alpha\"",
						TCL_STATIC );
		return TCL_ERROR;
	}

	if ( no == 0 ) /* transparent */
	{
		*r = *g = *b = *a = 0;
	}

	else if ( no < 3 )
	{
		Tcl_Obj *tp = obj;
		GdkColor color;

		if ( no == 2 )
		{
			if ( Tcl_ListObjIndex ( interp, obj, 0, &tp ) != TCL_OK )
				return TCL_ERROR;
		}

		/* take as string and reformat as a GdkColor structure */

		if ( gdk_color_parse ( Tcl_GetString ( tp ), &color ) == 0 )
		{
			Tcl_AppendResult ( interp, "unknown color \"", Tcl_GetString ( obj ), "\".", ( char * ) NULL );
			return TCL_ERROR;
		}

		*r = color.red;
		*g = color.green;
		*b = color.blue;

		if ( no == 2 )
		{
			if ( getShortValue ( interp, obj, 1, a ) != TCL_OK )
				return TCL_ERROR;
		}

		else
			*a = 0xFFFF;
	}

	else
	{
		if ( getShortValue ( interp, obj, 0, r ) != TCL_OK
				|| getShortValue ( interp, obj, 1, g ) != TCL_OK
				|| getShortValue ( interp, obj, 2, b ) != TCL_OK )
			return TCL_ERROR;

		if ( no == 4 )
		{
			if ( getShortValue ( interp, obj, 3, a ) != TCL_OK )
				return TCL_ERROR;
		}

		else
			*a = 0xFFFF;
	}

	return TCL_OK;
}

/**
\brief      Take colour values from a string format and assign them to
             location addressed by pointer *color.
\author     Peter G baum
\date
\note       From module parseoptions.c
\since      0.9.94
**/
static int getGdkColor ( Tcl_Interp *interp, Tcl_Obj *obj, GdkColor *color )
{
	int r, g, b, a;

	if ( getRGBA ( interp, obj, &r, &g, &b, &a ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	/* TODO? if a != 0xFFFF: alpha not supported? */
	color->red = r;

	color->green = g;

	color->blue = b;

	return TCL_OK;
}

/**
\brief      Function associated with the pixbufs.
\author     William J Giddings
\date       12-Feb-09
\since      0.9.94
**/
int pixBufFunc ( ClientData data, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	listParameters ( objc, objv, "pixBufFunc" );
#endif

	GdkPixbuf *pixbuf;
	pixbuf = GDK_PIXBUF ( data );

	static const char *cmds[] =
	{
		"copy", "delete", "configure", "duplicate",
		"cget", "draw", "class",
		"fill", "save", "turn",
		"flip", "rotate", "composite",
		"subpixbuf",
		"saturation", "pixelate", "colorize",
		"getPixel", "setPixel", "info", "filter",
		"scale", "resize",
		NULL
	};

	enum cmdIdx
	{
		CopyIdx, DeleteIdx, ConfigureIdx, DuplicateIdx,
		CgetIdx, DrawIdx, ClassIdx,
		FillIdx, SaveIdx, TurnIdx,
		FlipIdx, RotateIdx, CompositeIdx,
		SubPixBufIdx,
		SaturationIdx, PixelateIdx, ColorizeIdx,
		GetPixelIdx, SetPixelIdx, InfoIdx, FilterIdx,
		ScaleIdx, ResizeIdx
	};

	int idx;

	if ( objc < 2 )
	{
		Tcl_WrongNumArgs ( interp, 1, objv, "command" );
		return TCL_ERROR;
	}

	if ( Tcl_GetIndexFromObj ( interp, objv[1], cmds, "command", TCL_EXACT, &idx ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	switch ( idx )
	{

		case ScaleIdx:
			{
				GdkPixbuf *dest_pixbuf;
				GdkInterpType interp_type;
				interp_type = GDK_INTERP_BILINEAR;
				float xScale, yScale;
				gint w, h, i, resizeIdx;
				float dest_width, dest_height;

				static char *resizeOptions[] =
				{
					"-height", "-width",
					NULL
				};

				static enum  optsIdx
				{
					heightIdx, widthIdx
				};

				xScale = -1;
				yScale = -1;

				if ( objc == 3 )
				{

					sscanf ( Tcl_GetString ( objv[2] ), "%f", &xScale );
					yScale = xScale;

				}

				/* parse all the options */
				i = 2;

				while ( i < objc )
				{
					getIdx ( resizeOptions, Tcl_GetString ( objv[i] ), &resizeIdx );

					switch ( resizeIdx )
					{
						case heightIdx:
							{
#ifdef DEBUG_PIXBUF
								g_print ( "height\n" );
#endif

								sscanf ( Tcl_GetString ( objv[i+1] ), "%f", &yScale );

							} break;
						case widthIdx:
							{
#ifdef DEBUG_PIXBUF
								g_print ( "width\n" );
#endif
								sscanf ( Tcl_GetString ( objv[i+1] ), "%f", &xScale );
							} break;
						default:
							{
							}
					}

					i += 2;
				}

				if ( xScale == -1 )
				{
					xScale = yScale;

				}

				if ( yScale == -1 )
				{
					yScale = xScale;
				}


				if ( xScale == -1 && yScale == -1 )
				{
					xScale = 1;
					yScale = 1;
				}


				w = gdk_pixbuf_get_width ( pixbuf );
				h = gdk_pixbuf_get_height ( pixbuf );


				dest_width = ( float ) w * xScale;
				dest_height = ( float ) h * yScale;

#ifdef DEBUG_PIXBUF
				g_print ( "i = %d dest_width, dest_height = %f %f\n", i, dest_width, dest_height );
#endif
				dest_pixbuf = gdk_pixbuf_scale_simple (  pixbuf, ( int ) dest_width, ( int ) dest_height, interp_type );
				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );
			}
			break;
		case ResizeIdx:
			{

				GdkPixbuf *dest_pixbuf;
				GdkInterpType interp_type;
				interp_type = GDK_INTERP_BILINEAR;
				gint dest_width, dest_height;
				gint i, w, h;
				gint resizeIdx;


				dest_width = -1 ;
				dest_height = -1;

				static char *resizeOptions[] =
				{
					"-height", "-width",
					NULL
				};

				static enum  optsIdx
				{
					heightIdx, widthIdx
				};

				/* parse all the options */
				i = 2;

				while ( i < objc )
				{

					getIdx ( resizeOptions, Tcl_GetString ( objv[i] ), &resizeIdx );

					switch ( resizeIdx )
					{
						case heightIdx:
							{
#ifdef DEBUG_PIXBUF
								g_print ( "height\n" );
#endif

								sscanf ( Tcl_GetString ( objv[i+1] ), "%d", &dest_height );

							} break;
						case widthIdx:
							{
#ifdef DEBUG_PIXBUF
								g_print ( "width\n" );
#endif
								sscanf ( Tcl_GetString ( objv[i+1] ), "%d", &dest_width );
							} break;
						default:
							{
							}
					}

					i += 2;
				}

				//return TCL_OK;

				//i = sscanf ( Tcl_GetString ( objv[2] ), "%d %d", &dest_width, &dest_height );

				if ( dest_width == -1 &&  dest_height == -1 )
				{

#ifdef DEBUG_PIXBUF
					g_print ( "plain copy\n" );
#endif

					dest_pixbuf = gdk_pixbuf_copy ( pixbuf );
					return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );
				}


				if ( dest_height == -1 )
				{
					/* scale height in proportion to width */
					w = gdk_pixbuf_get_width ( pixbuf );
					h = gdk_pixbuf_get_height ( pixbuf );

					dest_height = dest_width * h / w;
				}

				if ( dest_width == -1 )
				{
					/* scale height in proportion to width */
					w = gdk_pixbuf_get_width ( pixbuf );
					h = gdk_pixbuf_get_height ( pixbuf );

					dest_width = dest_height * w / h;
				}


				dest_pixbuf = gdk_pixbuf_scale_simple (  pixbuf, dest_width, dest_height, interp_type );
				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );
			}
		case DuplicateIdx:
			{
				GdkPixbuf *dest_pixbuf;
				dest_pixbuf = gdk_pixbuf_copy ( pixbuf );
				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );
			}
			break;
		case FilterIdx:
			{
				gnoclPixBufFilters ( GDK_PIXBUF ( pixbuf ), interp, objc, objv );
			}
			break;
		case InfoIdx:
			{
				gchar str[32];
				gint w, h, a, bps, n;
				w = gdk_pixbuf_get_width ( pixbuf );
				h = gdk_pixbuf_get_height ( pixbuf );
				a = gdk_pixbuf_get_has_alpha ( pixbuf );
				bps = gdk_pixbuf_get_bits_per_sample ( pixbuf );
				n = gdk_pixbuf_get_n_channels ( pixbuf );

				sprintf ( str, "%d %d %d %d %d", w, h, a, bps, n );

				Tcl_SetResult ( interp, str, TCL_STATIC );

			}
			break;
		case SetPixelIdx:
			{

				gint x;
				gint y;

				gint w;
				gint h;

				guchar r;
				guchar g;
				guchar b;
				guchar a;

				/* set pixel location */
				sscanf ( Tcl_GetString ( objv[2] ), "%d %d", &x, &y );
				sscanf ( Tcl_GetString ( objv[3] ),  "%d %d %d %d", &r, &g, &b , &a );


				w = gdk_pixbuf_get_width ( pixbuf );
				h = gdk_pixbuf_get_height ( pixbuf );

				if ( 0 )
				{
					GdkColor color;

					if ( getGdkColor ( interp, Tcl_GetString ( objv[3] ), &color ) != TCL_OK )
					{
						return TCL_ERROR;
					}
				}

				//set_pixel_color ( pixbuf, x, y , r, g, b, a );
#ifdef DEBUG_PIXBUF
				g_printf ( "x =%d y =%d w =%d h =%d\n", x, y, w, h );
				g_printf ( "r =%d g =%d b =%d a =%d\n", r, g, b, a );
#endif

				/* error checking */
				if ( x < 0 || x > gdk_pixbuf_get_width ( pixbuf )  )
				{
					//   return FALSE;
				}

				if ( y < 0 || y > gdk_pixbuf_get_height ( pixbuf )  )
				{
					//  return FALSE;
				}

				gdk_pixbuf_set_pixel ( pixbuf, convertRGBtoPixel ( Tcl_GetString ( objv[3] ) ), x, y );


			}
			break;

		case GetPixelIdx:
			{

				gint x;
				gint y;

				guchar r;
				guchar g;
				guchar b;
				guchar a;

				double R, G, B, A;

				gchar str[24];

				/* get pixel location */
				sscanf ( Tcl_GetString ( objv[2] ), "%d %d", &x, &y );
#ifdef DEBUG_PIXBUF
				g_printf ( "pos = %d %d\n", x, y );
#endif
				gdk_pixbuf_get_pixel ( pixbuf, x, y , &r, &g, &b, &a );


				/* convert int to decimal float */

				R = ( double ) r / 255;
				G = ( double ) g / 255;
				B = ( double ) b / 255;
				A = ( double ) a / 255;

				sprintf ( str, "%f %f %f %f", R, G, B, A );

				Tcl_SetResult ( interp, str, TCL_STATIC );

			}
			break;
		case PixelateIdx:
			{
				GdkPixbuf *dest_pixbuf;
				double saturation;

				/* simplest way to get the a duplicate buffer to paste into */
				dest_pixbuf = gdk_pixbuf_copy ( pixbuf );

				if ( 0 )
				{
					if ( Tcl_GetDoubleFromObj ( interp, objv[2], &saturation ) != TCL_OK )
					{
						Tcl_SetResult ( interp, "Invalid value set for saturation, must be a float.\n", TCL_STATIC );
						return TCL_ERROR;
					}
				}

				gdk_pixbuf_saturate_and_pixelate ( pixbuf, dest_pixbuf, 1.0, TRUE );

				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );
			}
			break;
		case SaturationIdx:
			{

				GdkPixbuf *dest_pixbuf;
				double saturation;

				/* simplest way to get the a duplicate buffer to paste into */
				dest_pixbuf = gdk_pixbuf_copy ( pixbuf );

				if ( Tcl_GetDoubleFromObj ( interp, objv[2], &saturation ) != TCL_OK )
				{
					Tcl_SetResult ( interp, "Invalid value set for saturation, must be a float.\n", TCL_STATIC );
					return TCL_ERROR;
				}

				gdk_pixbuf_saturate_and_pixelate ( pixbuf, dest_pixbuf, saturation, FALSE );

				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );

			}
			break;
		case CopyIdx:
			{
#ifdef DEBUG_PIXBUF
				g_print ( "CopyIdx %s\n", Tcl_GetString ( objv[2] ) );
#endif

				int src_x;
				int src_y;
				int width;
				int height;
				GdkPixbuf *dest_pixbuf;

				dest_pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB, FALSE, 8, width, height );

				/* if no string is passed make a simple duplicate */
				if ( objc == 2 )
				{
#ifdef DEBUG_PIXBUF
					g_print ( "total args %d\n", objc );
#endif
					dest_pixbuf = gdk_pixbuf_copy ( pixbuf );
				}

				/* copy as specific region of the pixbuf */
				else
				{

					sscanf ( Tcl_GetString ( objv[2] ), "%d %d %d %d", &src_x, &src_y, &width, &height );
#ifdef DEBUG_PIXBUF
					g_print ( "CopyIdx %d %d %d %d\n", src_x, src_y, width, height );
#endif

					dest_pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB, FALSE, 8, width, height );

					gdk_pixbuf_copy_area ( pixbuf, src_x, src_y, width, height, dest_pixbuf, 0, 0 );
				}

				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );

			}
			break;
		case SubPixBufIdx :
			{

				int src_x;
				int src_y;
				int width;
				int height;

				GdkPixbuf *dest_pixbuf;
				gint i;

				if ( sscanf ( Tcl_GetString ( objv[2] ), "%d %d %d %d", &src_x, &src_y, &width, &height ) != 4 )
				{
					Tcl_SetResult ( interp, "Should be: pixBuf-id subpixBuf {x y w h}./n", TCL_STATIC );

					return TCL_ERROR;
				}

				dest_pixbuf = gdk_pixbuf_new_subpixbuf ( pixbuf, src_x, src_y, width, height );

				return gnoclRegisterPixBuf ( interp, dest_pixbuf, pixBufFunc );
			}
			break;
		case DeleteIdx:
			{
			}
			break;
		case ConfigureIdx:
			{
			}
			break;
		case CgetIdx:
			{

				static char *cgetOptions[] =
				{
					"-colorSpace", "-nChannels", "-hasAlpha",
					"-bitsPerSample", "-pixels", "-width",
					"-height", "-rowstride", "-key",
					NULL
				};

				static enum  optsIdx
				{
					ColorSpaceIdx, NChannelsIdx, HasAlphaIdx,
					BitsPerSampleIdx, PixelsIdx, WidthIdx,
					HeightIdx, RowStrideIdx, KeyIdx
				};

				int Idx;

				if ( Tcl_GetIndexFromObj ( interp, objv[2], cgetOptions, "option", TCL_EXACT, &Idx ) != TCL_OK )
				{
					return TCL_ERROR;
				}

				switch ( Idx )
				{
					case ColorSpaceIdx:
						{

							/* 05/03/10 only RGB supported */
							gchar *str;

							switch ( gdk_pixbuf_get_colorspace ( pixbuf ) )
							{
								case GDK_COLORSPACE_RGB:
									{
										str = "RGB";
									}
									break;
							}

							Tcl_SetObjResult ( interp, Tcl_NewStringObj ( str, -1  ) );

						} break;
					case NChannelsIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_bits_per_sample ( pixbuf ) ) );
						} break;
					case HasAlphaIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_has_alpha ( pixbuf ) ) );
						} break;
					case BitsPerSampleIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_bits_per_sample ( pixbuf ) ) );
						} break;
					case PixelsIdx:
						{
							/* Not terribly certain what this function implies */
							guchar *str;
							str = gdk_pixbuf_get_pixels ( pixbuf );

							Tcl_SetObjResult ( interp, Tcl_NewStringObj ( str, -1 ) );
						} break;
					case WidthIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_width ( pixbuf ) ) );
						} break;
					case HeightIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_height ( pixbuf ) ) );
						} break;
					case RowStrideIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_rowstride ( pixbuf ) ) );
						} break;
					case KeyIdx:
						{
//const gchar * gdk_pixbuf_get_option (GdkPixbuf *pixbuf,const gchar *key);
						}
						break;
				}
			}
			break;
		case ClassIdx:
			{
				Tcl_SetObjResult ( interp, Tcl_NewStringObj ( "pixbuf", -1 ) );
			}
			break;
		case FillIdx:
			{
				gdk_pixbuf_fill ( pixbuf, convertRGBtoPixel ( Tcl_GetString ( objv[2] ) ) );

			}
			break;
		case SaveIdx:
			{
				GError *err;
				gchar *opt, *val;
				gchar *fileType;
				gchar *fileName;
				gchar *parameters;


				/* set a default filetype */
				fileType = NULL;
				fileName = NULL;
				parameters = NULL;

				static char *newOptions[] =
				{
					"-fileName", "-fileType", "-parameters",
					NULL
				};

				static enum  optsIdx
				{
					FileNameIdx, FileTypeIdx, ParametersIdx
				};

				gint i, j;
				int idx;

				for ( i = 2; i < objc; i += 2 )
				{
					j = i + 1;

					opt = Tcl_GetString ( objv[i] );
					val = Tcl_GetString ( objv[j] );


					if ( Tcl_GetIndexFromObj ( interp, objv[i], newOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
					{
						return TCL_ERROR;
					}


					switch ( idx )
					{
						case FileNameIdx:
							{
								//g_printf ( "save file = %s val = %s\n", opt, val );
								err = NULL;
								fileName = val;

								if ( err != NULL )
								{
									g_warning ( err->message );
									g_error_free ( err );
								}
							}
							break;
						case FileTypeIdx:
							{

								GSList *p;

								//g_printf ( "file type = %s val = %s\n", opt, val );


								for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
								{
									//g_printf ( "p = %s\n", gdk_pixbuf_format_get_name ( p->data ) );

									if ( !strcmp ( val, gdk_pixbuf_format_get_name ( p->data ) ) )
									{
										//g_printf ( "ok an acceptable format!\n" );
										fileType = val;
										break;

									}
								}

								if ( fileType == NULL )
								{
									gchar str[64];
									sprintf ( str, "GNOCL ERROR: \"%s\" is not a supported file format.\n", val );
									Tcl_SetResult ( interp, str, TCL_STATIC );
									return TCL_ERROR;
								}

							}
							break;
						case ParametersIdx:
							{
								parameters = val;

							}
							break;
						default:
							{
							}
					}
				}

				//g_printf ( "parameters = %s\n", parameters );


				if ( parameters == NULL )
				{
					gdk_pixbuf_save ( pixbuf, fileName, fileType, &err, NULL ) ;
					break;
				}


				/* handle any received parameters */
				if ( parameters != NULL )
				{

					gchar **tmp_array, **iterator;
					gchar *props[10], *vals[10];
					gint  k;


					tmp_array = g_strsplit_set ( parameters, "= ", 0 );
					iterator = tmp_array;
					i = 0;

					/* do the actual split */
					while ( i < g_strv_length ( tmp_array ) / 2 )
					{

						props[i] = *iterator;
						iterator++;

						vals[i]  = *iterator;
						iterator++;

						i++;
					}

					props[i] = NULL; /* First array needs to be NULL terminated */

					gdk_pixbuf_savev ( pixbuf, fileName, fileType, props, vals, NULL );
					g_strfreev ( tmp_array );

				}

				else
				{
					/* "plain" save if no parameters set */
					gdk_pixbuf_save ( pixbuf, fileName, fileType, &err, NULL );
				}

			} break;
		case TurnIdx:
			{
				/*
				typedef enum {
				    GDK_PIXBUF_ROTATE_NONE             =   0,
				    GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE =  90,
				    GDK_PIXBUF_ROTATE_UPSIDEDOWN       = 180,
				    GDK_PIXBUF_ROTATE_CLOCKWISE        = 270
				} GdkPixbufRotation;
				*/


				int idx;
				int angle;

				angle = 0;

				static char *turnOptions[] =
				{
					"clockwise", "90",
					"counterClockwise", "antiClockwise", "270", "-90",
					"upsideDown", "180", "-180",
					NULL
				};

				static enum  optsIdx
				{
					ClockWiseIdx, _90Idx,
					CounterClockwiseIdx, AntiClockwiseIdx, _270Idx, _minus90Idx,
					UpsideDownIdx, _180Idx, _minus180Idx
				};

				if ( Tcl_GetIndexFromObj ( interp, objv[2], turnOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
				{
					return TCL_ERROR;
				}

				switch ( idx )
				{
					case ClockWiseIdx:
					case _90Idx:
						{
							angle = 90;
						}
						break;

					case CounterClockwiseIdx:
					case AntiClockwiseIdx:
					case _270Idx:
					case _minus90Idx:
						{
							angle = 270;
						}

					case UpsideDownIdx:
					case _180Idx:
					case _minus180Idx:
						{
							angle = 180;
						}
						break;
				}


				/* get rotated copy of the buffer */
				GdkPixbuf *pb;
				pb = gdk_pixbuf_rotate_simple ( pixbuf, angle );

				/* clear the parent buffer, then copy accross with composite  */
				gdk_pixbuf_fill ( pixbuf, 0x000000000000 );
				gdk_pixbuf_composite ( pb, pixbuf, 0, 0,
									   gdk_pixbuf_get_width ( pixbuf ),
									   gdk_pixbuf_get_height ( pixbuf ),
									   0, 0, 1, 1,
									   GDK_INTERP_BILINEAR, 255 );
				/* free the intermediary pixbuf*/
				g_object_unref ( pb );
			}
			break;
		case FlipIdx:
			{
				GdkPixbuf *pb;

				/* horizontal */
				pb = gdk_pixbuf_flip ( pixbuf, TRUE );
				/* vertical */
				pb = gdk_pixbuf_flip ( pixbuf, FALSE );

				/* clear the parent buffer, then copy accross with composite  */
				gdk_pixbuf_fill ( pixbuf, 0x000000000000 );
				gdk_pixbuf_composite ( pb, pixbuf, 0, 0,
									   gdk_pixbuf_get_width ( pixbuf ),
									   gdk_pixbuf_get_height ( pixbuf ),
									   0, 0, 1, 1,
									   GDK_INTERP_BILINEAR, 255 );
				/* free the intermediary pixbuf*/
				g_object_unref ( pb );

			}
			break;
		case RotateIdx:
			{
				/* todo:
				   associate the named object with the new buffer which will be enlarged.
				   error check, this will not work on svg files
				*/
				GdkPixbuf *pb;
				gdouble angle;
				int acolor;
				gchar *name;

				acolor = 255 ; /* default is black */

				name = gnoclGetNameFromPixBuf ( data );

				Tcl_GetDoubleFromObj ( NULL, objv[3], &angle );

				/* only one option */
				if ( !strcmp ( Tcl_GetString ( objv[4] ), "-backgroundColor" ) )
				{

					acolor = Tcl_GetIntFromObj ( NULL, objv[5], &acolor ) ;
				}

				else
				{

					Tcl_SetResult ( interp, "Unknown option. M\n", TCL_STATIC );
					return TCL_ERROR;
				}


#ifdef DEBUG_PIXBUF
				g_print ( "Rotate 2 %s %f %s %d\n",
						  name ,
						  angle,
						  Tcl_GetString ( objv[5] ),
						  acolor ); // works ok!
#endif
				/* replace the current buffer with the new buffer */
				pb = pixbufRotate ( pixbuf, angle, acolor );

				if ( pb == NULL )
				{
					Tcl_SetResult ( interp, "Unable to create pixBuff\n", TCL_STATIC );
					return TCL_ERROR;
				}

				return gnoclRegisterPixBuf ( interp, pb, pixBufFunc );

			}
			break;
		case CompositeIdx:
			{
				/* this will clearly need parameters sorted from outset */
#ifdef DEBUG_PIXBUF
				g_print ( "CompositeIdx 1\n" );
				g_printf ( "objc = %d\n", objc );
				listParameters ( objc, objv );
#endif

				int compositeIdx;
				static const char *compositeOpts[] =
				{
					"-destX", "-destY",
					"-destWidth", "-destHeight",
					"-offsetX", "-offsetY",
					"-scaleX", "-scaleY",
					"-interpType",
					"-alpha",
					NULL
				};

				enum compIdx
				{
					DestXIdx, DestYIdx,
					DestWidthIdx, DestHeightIdx,
					OffsetXIdx, OffsetYIdx,
					ScaleXIdx, ScaleYIdx,
					InterpTypeIdx,
					AlphaIdx
				};

				/* check the number of arguments */
				if ( objc < 2 )
				{
					Tcl_SetObjResult ( interp, Tcl_NewStringObj ( "ERROR: Wrong number of arguments.", -1  ) );
					return TCL_ERROR;
				}

				GdkPixbuf *src, *dest;

				/* composite options */
				gint dest_x, dest_y;
				gint dest_width, dest_height;
				gdouble offset_x, offset_y;
				gdouble scale_x, scale_y;
				GdkInterpType interp_type;
				gint overall_alpha;

				src = gnoclGetPixBufFromName ( Tcl_GetString ( objv[2] ), interp );
				dest = pixbuf;

				/* set some defaults */
				dest_x = 0;
				dest_y = 0;
				dest_width = gdk_pixbuf_get_width ( src );
				dest_height = gdk_pixbuf_get_height ( src );

				offset_x = 0;
				offset_y = 0;
				scale_x = 1;
				scale_y = 1;
				interp_type = GDK_INTERP_BILINEAR;
				overall_alpha = 255;

				gint i; /* counter */

				/* parse all the options */
				i = 3;

				while ( i < objc )
				{

					getIdx ( compositeOpts, Tcl_GetString ( objv[i] ), &compositeIdx );

					switch ( compositeIdx )
					{
						case DestXIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &dest_x );
							}
							break;
						case DestYIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &dest_y );
							}
							break;
						case DestWidthIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &dest_width );
							}
							break;
						case DestHeightIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &dest_height );
							}
							break;
						case OffsetXIdx:
							{
								Tcl_GetDoubleFromObj ( NULL, objv[i+1], &offset_x );
							}
							break;
						case OffsetYIdx:
							{
								Tcl_GetDoubleFromObj ( NULL, objv[i+1], &offset_y );
							}
							break;
						case ScaleXIdx:
							{
								Tcl_GetDoubleFromObj ( NULL, objv[i+1], &scale_x );
							}
							break;
						case ScaleYIdx:
							{
								Tcl_GetDoubleFromObj ( NULL, objv[i+1], &offset_y );
							}
							break;
						case InterpTypeIdx:
							{
								interp_type = GDK_INTERP_BILINEAR;
							}
							break;
						case AlphaIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &overall_alpha );
							}
							break;
						default: {}
					}

					i += 2;
				}

				/* reset values based upon received switches */

				gdk_pixbuf_composite ( src, dest,
									   dest_x, dest_y,
									   dest_width, dest_height,
									   offset_x, offset_y,
									   scale_x, scale_y,
									   interp_type, overall_alpha );
			}
			break;
		case DrawIdx:
			{
				/* draw the pixbuf to a GdkDrawable: ie. a drawing area */
				GtkWidget *widget;
				GdkDrawable *dest;
				gint src_x, src_y;
				gint dest_x, dest_y;
				gint width, height;
				gint x_dither, y_dither;

				/* initialize the values with defaults */
				src_x = 0;
				src_y = 0;
				dest_x = 10;
				dest_y = 10;

				x_dither = 0;
				y_dither = 0;

				/* what size of the buffer has to be drawn */
				width = gdk_pixbuf_get_width ( pixbuf );
				height = gdk_pixbuf_get_height ( pixbuf );

				widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[2] ), interp );

				if ( widget == NULL )
				{
					return TCL_ERROR;
				}

				dest = GDK_DRAWABLE ( widget->window );

				/* change values based upon switches passed */
				gdk_draw_pixbuf (
					dest,
					gdk_gc_new ( widget->window ),
					pixbuf,
					src_x, src_y,
					dest_x, dest_y,
					width,
					height,
					GDK_RGB_DITHER_NONE,
					x_dither, y_dither );

			}
			break;
	}

	return TCL_OK;
}


/**
\brief
\author     William J Giddings
\date       12-Feb-09
\since      0.9.94
\note      "char *" and not "const char *" because of a not very strict
            handling of "const char *" in Tcl e.g. Tcl_CreateObjCommand
*/


char *gnoclGetAutoPixBufId ( void )
{
	static int no = 0;
	/*
	static char buffer[30];
	*/

	char *buffer = g_new ( char, sizeof ( idPrefix ) + 15 );
	strcpy ( buffer, idPrefix );

	/* with namespace, since the Id is also the widget command */
	sprintf ( buffer + sizeof ( idPrefix ) - 1, "%d", ++no );

	return buffer;
}

/**
\brief
\author     William J Giddings, Peter G Baum
\date
\since      0.9.94
**/
/* -----------------
   handle widget <-> name mapping
-------------------- */
GdkPixbuf *gnoclGetPixBufFromName ( const char * id, Tcl_Interp * interp )
{
#ifdef DEBUG_PIXBUF
	g_print ( "%s\n", __FUNCTION__ );
#endif

	GdkPixbuf *pixbuf = NULL;
	int       n;

	if ( strncmp ( id, idPrefix, sizeof ( idPrefix ) - 1 ) == 0
			&& ( n = atoi ( id + sizeof ( idPrefix ) - 1 ) ) > 0 )
	{
		pixbuf = g_hash_table_lookup ( name2pixbufList, GINT_TO_POINTER ( n ) );
	}

	if ( pixbuf == NULL && interp != NULL )
	{
		Tcl_AppendResult ( interp, "Unknown pixbuf \"", id, "\".", ( char * ) NULL );
	}

	return pixbuf;
}

/**
\brief      Returns the widget name associated with pointer
\author     Peter G Baum
\date
\since      0.9.94
**/
const char *gnoclGetNameFromPixBuf ( GdkPixbuf * pixbuf )
{
	const char *name = g_object_get_data ( G_OBJECT ( pixbuf ), "gnocl::name" );

	return name;
}

/**
\brief
\author Peter G Baum
\date
\since      0.9.94
**/
int gnoclForgetPixBufFromName ( const char * path )
{
	int n = atoi ( path + sizeof ( idPrefix ) - 1 );
	assert ( gnoclGetPixBufFromName ( path, NULL ) );
	assert ( strncmp ( path, idPrefix, sizeof ( idPrefix ) - 1 ) == 0 );
	assert ( n > 0 );

	g_hash_table_remove ( name2pixbufList, GINT_TO_POINTER ( n ) );

	return 0;
}

/**
\brief
\author     William J Giddings
\date       12-Feb-09
\since      0.9.94
**/
static void simpleDestroyFunc ( GdkPixbuf * pixbuf, gpointer data )
{
	const char *name = gnoclGetNameFromPixBuf ( pixbuf );
	gnoclForgetPixBufFromName ( name );
	Tcl_DeleteCommand ( ( Tcl_Interp * ) data, ( char * ) name );
	g_free ( ( char * ) name );
}

/**
\brief
\author     William J Giddings
\date       12-Feb-09
\since      0.9.94
**/
int gnoclMemNameAndPixBuf ( const char * path,  GdkPixbuf * pixbuf )
{
	int n ;

	n = atoi ( path + sizeof ( idPrefix ) - 1 );

	assert ( n > 0 );
	assert ( g_hash_table_lookup ( name2pixbufList, GINT_TO_POINTER ( n ) ) == NULL );
	assert ( strncmp ( path, idPrefix, sizeof ( idPrefix ) - 1 ) == 0 );

	/* memorize the name of the widget in the widget */
	g_object_set_data ( G_OBJECT ( pixbuf ), "gnocl::name", ( char * ) path );
	g_hash_table_insert ( name2pixbufList, GINT_TO_POINTER ( n ), pixbuf );

	return 0;
}

/**
\brief
\author    William J Giddings
\date
\since     0.9.94
**/
int gnoclRegisterPixBuf ( Tcl_Interp * interp, GdkPixbuf * pixbuf, Tcl_ObjCmdProc * proc )
{

	const char *name;

	name = gnoclGetAutoPixBufId();

	gnoclMemNameAndPixBuf ( name, pixbuf ); //<--- problems here

	//g_signal_connect_after ( G_OBJECT ( pixbuf ), "destroy", G_CALLBACK ( simpleDestroyFunc ), interp );

	if ( proc != NULL )
	{

		Tcl_CreateObjCommand ( interp, ( char * ) name, proc, pixbuf, NULL );
	}

	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( name, -1 ) );

	return TCL_OK;
}

/**
\brief      Convert colour to hexadecimal.
**/
int gnoclRGB2HexCmd ( ClientData data, Tcl_Interp * interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	listParameters ( objc, objv, "gnoclRGB2HexCmd" );
#endif

	GdkColor color;
	gchar str[25];
	gint val;

	getGdkColor ( interp, objv[1], &color );
	sprintf ( str, "#%.2x%.2x%.2x", color.red, color.green, color.blue );

	/* differentiate between 8 / 16 bit colour */
	if ( strcmp ( Tcl_GetString ( objv[2] ), "-8bit" ) == 0 )
	{
		Tcl_GetIntFromObj ( NULL, objv[3], &val );

		/* value of 0 means 16-bit */
		if ( !val )
		{
			color.red *= 257;
			color.green *= 257;
			color.blue *= 257;
			sprintf ( str, "#%.4x%.4x%.4x", color.red, color.green, color.blue );
		}

	}

	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( &str, -1 ) ) ;

	return TCL_OK;
}

/**
\brief      Convert colour 16-bit RGB decimal.
**/
int gnoclClr2RGBCmd ( ClientData data, Tcl_Interp * interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	g_printf ( "gnoclClr2RGBCmd\n" );
	gint _i;


	for ( _i = 0; _i < objc; _i++ )
	{
		g_printf ( "\targ %d = %s\n", _i,  Tcl_GetString ( objv[_i] ) );
	}

#endif

	GdkColor color;
	gchar str[25];
	gint val;

	getGdkColor ( interp, objv[1], &color );

	/* differentiate between 8 / 16 bit colour */
	if ( strcmp ( Tcl_GetString ( objv[2] ), "-8bit" ) == 0 )
	{
		Tcl_GetIntFromObj ( NULL, objv[3], &val );

		if ( !val )
		{

			color.red *= 257;
			color.green *= 257;
			color.blue *= 257;
		}

	}

	sprintf ( str, "%d %d %d", color.red, color.green, color.blue );
	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( &str, -1 ) ) ;

	return TCL_OK;
}


/**
\brief
\author     William J Giddings
\date       17-Jan-2010
\since      0.9.94
**/
int gnoclPixBufCmd ( ClientData data, Tcl_Interp * interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	listParameters ( objc, objv, "gnoclpixBufCmd" );
#endif

	/* create new hash table if one does not exist */
	if ( name2pixbufList == NULL )
	{
		name2pixbufList = g_hash_table_new ( g_direct_hash, g_direct_equal );
	}

	static const char *cmd[] =
	{
		"get", "render", "types",
		"description", "license", "licence",
		"extensions", "scalable", "writable",
		"fileInfo", "new", "load",
		"snapshot", "screenshot",
		"logo",
		NULL
	};

	enum cmdIdx
	{
		GetIdx, RenderIdx, TypesIdx,
		DescriptionIdx, LicenseIdx, LicenceIdx,
		ExtensionsIdx, ScalableIdx, WritableIdx,
		FileInfoIdx, NewIdx, LoadIdx,
		SnapshotIdx, ScreenshotIdx,
		LogoIdx
	};

	int cIdx;

	/* set relevant options for commands / sub-commands */
	const int opt1Idx = 0;
	const int opt2Idx = 1;
	const int opt3Idx = 2;

	GnoclOption cmd2Options[] =
	{
		{ "-option1", GNOCL_STRING, "", NULL},
		{ "-option2", GNOCL_STRING, "", NULL },
		{ "-option3", GNOCL_STRING, "", NULL },
		{ NULL }
	};

	/* must have the form <command-name> action objectName <options> */
	/*
		if ( objc <= 1 )
		{
			Tcl_WrongNumArgs ( interp, 1, objv, "command option... " );
			return TCL_ERROR;
		}
	*/
	if ( Tcl_GetIndexFromObj ( interp, objv[1], cmd, "option", TCL_EXACT, &cIdx ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	switch ( cIdx )
	{
		case ScreenshotIdx:
			{
#ifdef DEBUG_PIXBUF
				g_printf ( "objc = %d\n", objc );
#endif
				listParameters ( objc, objv );

				GdkWindow *window_root;
				GdkPixbuf *screenshot;
				gint x, y, x2, y2, width, height;
				float cx, cy;
				gint px, py;
				gint rw, rh;
				gint showPointer;

				/* set some defaults */
				x = 0, y = 0;

				/* get necessary values from the root window */
				window_root = gdk_get_default_root_window ();
				gdk_window_get_pointer ( window_root, &px, &py, NULL );
				gdk_window_get_geometry  ( window_root, NULL, NULL, &rw, &rh, NULL );

				if ( objc == 2 )
				{
					/* grab the whole screen */
					width = rw;
					height = rh;

				}

				else if ( objc = 4 )
				{
					/* check sub-command, region pointer -graphic */
					if ( strcmp ( Tcl_GetString ( objv[2] ), "region" ) == 0 )
					{
						sscanf ( Tcl_GetString ( objv[3] ), "%d %d %d %d", &x, &y, &width, &height );

						if ( strcmp ( Tcl_GetString ( objv[4] ), "-pointer" ) == 0 )
						{
							Tcl_GetIntFromObj ( NULL, objv[5], &showPointer );
						}
					}

					if ( strcmp ( Tcl_GetString ( objv[2] ), "pointer" ) == 0 )
					{

						sscanf ( Tcl_GetString ( objv[3] ), "%d %d", &width, &height );
						/* ensure that pointer at the centre of the grab */
						x = px - width / 2;
						y = py - height / 2;

						/* apply some error checks */
						if ( px <= width / 2 )
						{
							x = 0;
						}

						if ( py <= height / 2 )
						{
							y = 0;
						}

						if ( px > rw - width )
						{
							x = px - width + 1;
						}

						if ( py > rh - height )
						{
							y = py - height + 1;
						}
					}

				}

				screenshot = gdk_pixbuf_get_from_drawable ( NULL, window_root, NULL, x, y , 0, 0, width, height );

				cx = ( float ) px - x;
				cy = ( float ) py - y;

				cairo_t *cr;


				cr = gnoclPixbufCairoCreate ( screenshot );


				cairo_set_line_width ( cr, 9 );

				//cairo_set_source_rgb ( cr, 0.69, 0.19, 0 );
				cairo_set_source_rgba ( cr, 1.0, 0, 0, 0.25 );

				/* do the drawing */
				cairo_arc ( cr, cx, cy, 20, 0, 2 * G_PI );

				cairo_stroke_preserve ( cr );

				cairo_fill ( cr );

				screenshot = gnoclPixbufCairoDestroy ( cr, FALSE );

				GdkPixbuf * pointerPB = gdk_pixbuf_new_from_inline ( -1, gnocl_pointer, FALSE, NULL );

				gdk_pixbuf_composite ( pointerPB, screenshot, px - x, py - y,
									   gdk_pixbuf_get_width ( pointerPB ),
									   gdk_pixbuf_get_height ( pointerPB ),
									   0, 0, 1, 1,
									   GDK_INTERP_BILINEAR, 255 );

				return gnoclRegisterPixBuf ( interp, screenshot, pixBufFunc );

			}

			break;
		case SnapshotIdx:
			{
				g_print ( "SS 1 %s\n", Tcl_GetString ( objv[2] ) );
				GtkWidget *widget;
				widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[2] ), interp  );

				/* must be a toplevel */
				widget = gtk_widget_get_toplevel ( widget );

				if ( widget == NULL )
				{
					g_print ( "WARNING\n" );
					return TCL_OK;
				}

				g_print ( "SS 2\n" );

				GdkWindow *window_root;
				GdkPixbuf *pb;
				GdkRectangle rect;
				gint x, y, width, height;

				window_root = gdk_get_default_root_window ();
				g_print ( "SS 3\n" );
				//gdk_window_get_geometry  ( widget->window, NULL, NULL, &width, &height, NULL );
				//gdk_window_get_position (widget->window,&x, &y);


				gdk_window_get_frame_extents ( widget->window, &rect );
				g_print ( "SS 4\n" );

				g_print ( "%d %d %d %d \n", rect.x, rect.y, rect.width, rect.height );

				pb = gdk_pixbuf_get_from_drawable ( NULL, window_root, NULL, rect.x, rect.y, 0, 0, rect.width, rect.height );
				//pb = gdk_pixbuf_get_from_drawable ( NULL, widget->window, NULL,1,1, 0, 0, rect.width, rect.height);

				//gdk_pixbuf_save (screenshot, "screenshot.jpg", "jpeg", NULL, "quality", "100", NULL);
				return gnoclRegisterPixBuf ( interp, pb, pixBufFunc );

			}

			break;
			/* create gnocl_logo from in-line data */
		case LogoIdx:
			{
				GdkPixbuf *pixbuf;
				pixbuf = gdk_pixbuf_new_from_inline ( -1, gnocl_logo, FALSE, NULL );
				/* register the new item */
				return gnoclRegisterPixBuf ( interp, pixbuf, pixBufFunc );

			}
			break;
			/* implement template with subcommands and */
		case GetIdx:
			{
				static const char *subCmd[] = { "drawable", "image", "pointer", NULL };
				enum subCmdtIdx { DrawableIdx, ImageIdx, PointerIdx };
				int scIdx;
				Tcl_Obj *tp;

				if ( Tcl_GetIndexFromObj ( interp, objv[2], subCmd, "option", TCL_EXACT, &scIdx ) != TCL_OK )
				{
					return TCL_ERROR;
				}

				/* error handling done within swith case code */
				/*
								if ( objc < 3 )
								{
									return TCL_ERROR;
								}
				*/

				switch ( scIdx )
				{
					case ImageIdx:
					case DrawableIdx:
						{

							/* create a new buffer from the buffer associated with a specific drawable object
							   only works for object already rendered to screen
							*/

							GtkWidget *widget;
							widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[3] ), interp  );

							if ( widget == NULL )
							{
								//widget = gnoclGetPixMapFromName ( Tcl_GetString ( objv[3] ), interp  );
								//if (widget == NULL) {
								return TCL_ERROR;
								//}
							}

							int x, y, width, height, depth;
							GdkPixbuf *pixbuf;

							gdk_window_get_geometry ( widget->window, &x, &y, &width, &height, &depth );


							pixbuf = gdk_pixbuf_get_from_drawable (
										 NULL,
										 GDK_DRAWABLE ( widget->window ),
										 NULL,
										 0, 0,
										 0, 0,
										 width, height );


							/* register the new item */
							return gnoclRegisterPixBuf ( interp, pixbuf, pixBufFunc );

						}
						break;

					case PointerIdx:
						{

							if ( objc != 3 )
							{
								return TCL_ERROR;
							}

							g_printf ( "Create a pixbuf from the current pointer\n", Tcl_GetString ( objv[3] ) );
							GdkPixbuf *pixbuf;
							GdkCursor *cursor;
							GtkWidget *widget;

							widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[3] ), interp  );
							cursor = gdk_window_get_cursor ( widget->window );
							pixbuf = gdk_cursor_get_image ( cursor );

							/* register the new item */
							return gnoclRegisterPixBuf ( interp, pixbuf, pixBufFunc );
						}
						break;
				}
			}
			break;
		case RenderIdx:
			{
				/* set relevant options for commands / sub-commands */
				static char *cmd2Options[] = { "-option1", "-option2", "-option3",  NULL};
				static enum  optsIdx { opt1Idx, opt2Idx, opt3Idx };

				/* this one has the options usage:
				    gnocl::<CmdName> command item -option val..
				*/
				int ret;

				ret = compare ( Tcl_GetString ( objv[2] ), cmd2Options );

				switch ( ret )
				{
					case opt1Idx:
						{
							g_printf ( "\t\toption1, parameters = %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
					case opt2Idx:
						{
							g_printf ( "\t\toption2, parameters = %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
					case opt3Idx:
						{
							g_printf ( "\t\toption3, parameters = %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
				}

			}
			break;
		case TypesIdx:
			{
				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );

				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{

					Tcl_ListObjAppendElement ( interp, resList,
											   Tcl_NewStringObj ( gdk_pixbuf_format_get_name ( p->data ), -1 ) );

				}

				g_free ( p );
				Tcl_SetObjResult ( interp, resList );
			}
			break;
		case DescriptionIdx:
			{
				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );
				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						Tcl_SetObjResult ( interp, Tcl_NewStringObj ( gdk_pixbuf_format_get_description ( p->data ), -1 ) );
					}
				}

				g_free ( p );


			}
			break;
		case LicenceIdx:
		case LicenseIdx:
			{
				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );
				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						Tcl_SetObjResult ( interp, Tcl_NewStringObj ( gdk_pixbuf_format_get_license ( p->data ), -1 ) );
					}
				}

				g_free ( p );


			}
			break;
		case ExtensionsIdx:
			{
				gchar * extensions;
				gchar **extension_list;

				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );
				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{

						extension_list = gdk_pixbuf_format_get_extensions ( p->data );
						extensions = g_strjoinv ( " ", extension_list );
						g_strfreev ( extension_list );

						Tcl_SetObjResult ( interp, Tcl_NewStringObj ( extensions, -1 ) );
					}
				}

				g_free ( p );


			}
			break;
		case ScalableIdx:
			{

				GSList *p;

				gint res = -1;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						res = gdk_pixbuf_format_is_scalable ( p->data );
					}
				}

				g_free ( p );

				Tcl_SetObjResult ( interp, Tcl_NewIntObj ( res ) ) ;


			}
			break;
		case WritableIdx:
			{

				GSList *p;

				gint res = -1;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						res = gdk_pixbuf_format_is_writable ( p->data );
					}
				}

				g_free ( p );

				Tcl_SetObjResult ( interp, Tcl_NewIntObj ( res ) ) ;
			}
			break;
		case FileInfoIdx:
			{

				GdkPixbufFormat *format;
				gint width;
				gint height;
				gchar str[128];

				format = gdk_pixbuf_get_file_info ( Tcl_GetString ( objv[2] ), &width, &height );

				sprintf ( str, "%d %d %s\n", width, height, gdk_pixbuf_format_get_name ( format ) );

				Tcl_SetObjResult ( interp, Tcl_NewStringObj ( &str, -1 ) ) ;

			}
			break;
		case NewIdx:
			{
				GdkPixbuf *pixbuf;
				gchar *name;

				gint width, height, bps, alpha;
				gchar *opt, *val;
				gint clrspace;

				/* set some default values, then re-assign based upon received values */
				width = 640;
				height = 480;
				bps = 8;
				alpha = 0;
				clrspace = GDK_COLORSPACE_RGB;

				static char *newOptions[] =
				{
					"-width", "-height", "-bitsPerSample", "-colorSpace",
					"-alpha", "-name", "-data",
					NULL
				};

				static enum  optsIdx
				{
					WidthIdx, HeightIdx,
					BitsPerSampleIdx, ColorSpaceIdx,
					AlphaIdx, NameIdx, DataIdx
				};

				gint i, j;
				int idx;

				/* create the buffer,note: only RGB suported */
				//sscanf ( Tcl_GetString ( objv[2] ), "%d %d %d", &width, &height, &bps );
				//pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB, alpha, bps, width, height );

				/* parse remaining the switches */
				/* set relevant options for commands / sub-commands */

				for ( i = 2; i < objc; i += 2 )
				{
					j = i + 1;

					opt = Tcl_GetString ( objv[i] );
					val = Tcl_GetString ( objv[j] );

					if ( Tcl_GetIndexFromObj ( interp, objv[i], newOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
					{
						return TCL_ERROR;
					}


					switch ( idx )
					{
						case ColorSpaceIdx:
							{
								g_printf ( "GNOCL WARNING: Currently only GDK_COLORSPACE_RGB supported, set by default.\n" );
							}
							break;
						case WidthIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &width );
							}
							break;
						case HeightIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &height );
							}
							break;
						case AlphaIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &alpha );

								if ( alpha != 0 )
								{
									alpha = 1;
								}
							}
							break;
						case BitsPerSampleIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &bps );
							} break;
						case NameIdx:
							{
								g_printf ( "%s Yet to be implemented.", val );
							}
							break;
						case DataIdx:
							{
								g_printf ( "%s Yet to be implemented.", val );;
							}
							break;
						default:
							{
								return TCL_ERROR;
							}
					}

				} /* end of switch parsing */

				pixbuf = gdk_pixbuf_new ( clrspace, alpha, bps, width, height );


				return gnoclRegisterPixBuf ( interp, pixbuf, pixBufFunc );
				//Tcl_SetObjResult ( interp, Tcl_NewStringObj ( name, -1 ) ) ;
			} break;
		case LoadIdx:
			{
				// GdkPixbuf * gdk_pixbuf_new_from_file (const char *filename, GError **error);
				GdkPixbuf *pixbuf;
				gchar *opt, *val;
				gchar *filename;


				static char *newOptions[] =
				{
					"-file", "-width", "-height", "-aspectRatio", "-inLine", NULL
				};

				static enum  optsIdx
				{
					FileIdx, WidthIdx, HeightIdx, AspectRatioIdx, InLineIdx
				};

				gint i, j;
				int idx;

				/* set some default values */
				gint height = 0;
				gint width = 0;
				gint aspect = 1;

				for ( i = 2; i < objc; i += 2 )
				{
					j = i + 1;

					opt = Tcl_GetString ( objv[i] );
					val = Tcl_GetString ( objv[j] );


					if ( Tcl_GetIndexFromObj ( interp, objv[i], newOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
					{
						return TCL_ERROR;
					}

					switch ( idx )
					{
						case InLineIdx:
							{

								/* choose from a list of preset inline graphics */
								GdkPixbuf *pixbuf;


								static char *inlinePB[] = {"logo", "pointer", NULL };
								static enum  inlinePBIdx { LogoIdx, PointerIdx };
								int idx;

								if ( Tcl_GetIndexFromObj ( interp,  objv[j] , inlinePB, "command", TCL_EXACT, &idx ) != TCL_OK )
								{
									return TCL_ERROR;
								}

								/* determine which built-in graphic to use */
								switch ( idx )
								{
									case LogoIdx:
										{
											pixbuf = gdk_pixbuf_new_from_inline ( -1, gnocl_logo, FALSE, NULL );
										}
									case PointerIdx:
										{
											pixbuf = gdk_pixbuf_new_from_inline ( -1, gnocl_pointer, FALSE, NULL );
										}
								}

								if ( pixbuf == NULL )
								{
									/* add suitable error message */
									gchar *errmsg;
									sprintf ( errmsg, "ERROR: Cannot load inline image \"%s\".\n", Tcl_GetString ( objv[3] ) );
									Tcl_SetResult ( interp, errmsg , TCL_STATIC );
									return TCL_ERROR;
								}

								/* register the new item */
								return gnoclRegisterPixBuf ( interp, pixbuf, pixBufFunc );

							}
							break;

						case HeightIdx:
							{
								height = atoi ( val );
							}
							break;
						case WidthIdx:
							{
								width = atoi ( val );
							}
							break;
						case FileIdx:
							{
								//g_printf ( "load file = %s val = %s\n", opt, val );
								//pixbuf = gdk_pixbuf_new_from_file ( val, NULL );
								filename = val;
							}
							break;
						case AspectRatioIdx:
							{
								/* need error check, its a boolean! */
								aspect = atoi ( val );
							}
							break;
						default:
							{
							}
					}
				}


				if ( height != 0 && width != 0 )
				{
					//printf ( "OK!! height = %d width = %d\n", height, width );
					pixbuf = gdk_pixbuf_new_from_file_at_scale ( filename, width, height, aspect, NULL );
				}

				else
				{
					//printf ( "NOPE!! height = %d width = %d\n", height, width );
					pixbuf = gdk_pixbuf_new_from_file ( val, NULL );
				}

				return gnoclRegisterPixBuf ( interp, pixbuf, pixBufFunc );
			}
			break;
	}

	return TCL_OK;
}

/**
\brief      Obtain colour and alpha values from an RGBA pixBuf.
\author     William J Giddings
\date       06/03/10
\since      0.9.94
**/
void gdk_pixbuf_get_pixel ( GdkPixbuf * pixbuf, guint x, guint y , guchar * r, guchar * g, guchar * b, guchar * a )
{
	guchar *pixels;
	guchar *p;
	guint w, h;
	guint rowstride, n_channels;

	g_return_if_fail ( GDK_IS_PIXBUF ( pixbuf ) );

	w = gdk_pixbuf_get_width ( pixbuf );
	h = gdk_pixbuf_get_height ( pixbuf );

	if ( w == 0 || h == 0 )
	{
		return;
	}

	if ( x > w || y > h )
	{
		return;
	}

	pixels = gdk_pixbuf_get_pixels ( pixbuf );
	rowstride = gdk_pixbuf_get_rowstride ( pixbuf );
	n_channels = gdk_pixbuf_get_n_channels ( pixbuf );

	p = pixels + x * n_channels + y * rowstride;

	*r = p[0];
	*g = p[1];
	*b = p[2];
	*a = ( n_channels == 4 ) ? p[3] : 0;

}


/*---------------------------------------------------------------------*/

/**
 * gdk_pixbuf_fill:
 * @pixbuf: a #GdkPixbuf
 * @pixel: RGBA pixel to clear to
 *         (0xffffffff is opaque white, 0x00000000 transparent black)
 *
 * Clears a pixbuf to the given RGBA value, converting the RGBA value into
 * the pixbuf's pixel format. The alpha will be ignored if the pixbuf
 * doesn't have an alpha channel.
 *
 **/
/**
\brief      Obtain colour and alpha values from an RGBA pixBuf.
\author     William J Giddings
\date       06/03/10
\since      0.9.94
\note       Adaptation of gdk_pixbuf_fill
**/
void gdk_pixbuf_set_pixel ( GdkPixbuf * pixbuf, guint32 pixel, guint x, guint y )
{
	guchar *pixels;
	guint r, g, b, a;
	guchar *p;
	guint w, h;
	guint rowstride, n_channels;

	g_return_if_fail ( GDK_IS_PIXBUF ( pixbuf ) );

	w = gdk_pixbuf_get_width ( pixbuf );
	h = gdk_pixbuf_get_height ( pixbuf );

	if ( w == 0 || h == 0 )
	{
		return;
	}

	if ( x > w || y > h )
	{
		return;
	}

	pixels = gdk_pixbuf_get_pixels ( pixbuf );
	rowstride = gdk_pixbuf_get_rowstride ( pixbuf );
	n_channels = gdk_pixbuf_get_n_channels ( pixbuf );

	r = ( pixel & 0xff000000 ) >> 24;
	g = ( pixel & 0x00ff0000 ) >> 16;
	b = ( pixel & 0x0000ff00 ) >> 8;
	a = ( pixel & 0x000000ff );

	p = pixels + y * rowstride + x * n_channels;

	switch ( n_channels )
	{
		case 3:
			{
				p[0] = r;
				p[1] = g;
				p[2] = b;
			}
			break;
		case 4:
			{
				p[0] = r;
				p[1] = g;
				p[2] = b;
				p[3] = a;
			}
			break;
		default:
			break;
	}
}


