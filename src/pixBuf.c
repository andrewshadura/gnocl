/** pixBuf.c
\brief     pixBufs are offscreen drawables.
\author    William J Giddings email: wjgiddings@blueyonder.co.uk
\date      17-Jan-2010
\version   0.9.95
\note      Module generated by gnocl_template_assistant.
\bugs      SVG rotation and composition produce errors.
\history
			02/06/11	implmented PixbufParams, create pixbuf with
						assocated Cairo surface
			06/09/10	composite -completed implementation of all options
			17/08/10	pixbuf commands
							snapshot
							screenshot
            09/04/10    pixbuf command
                            duplicate
            15/03/10    pixbuf command
                            info
            05/03/10
                        pixbuf command
                            setPixel
            02/03/10    pixbuf command
                            get drawable | image
                            render
            26/02/10    pixbuf command
                            subpixbuf
            20/02/10    pixbuf command
                            copy
            16/02/10    pixbuf command
                            draw
            15/02/10    pixbuf commands
                            composite
                            resize
                            scale
            14/02/10    pixbuf commands
                            turn
                            flip
                            rotate
                        commands
                            load

            13/02/10    pixbuf commands
                            save
                            fill
                            class
            12/02/10    commands
                            new
            11/02/10    commands
                            types
                            description <type>
                            license | licence <type>
                            extension <type>
                            scaleble <type>
                            writable <type>
                            fileInfo <fileName>
\todo
        1) Resolve what acolor actually does.
        2) Perform alpha channel operations.
            set, erase, get
**/

/**
\page page_pixbuf gnocl::pixBuf
\htmlinclude pixbuf.html
**/

#include "gnocl.h"
#include "gnoclparams.h"
#include "gnocl_logo.h"
#include "gnocl_pointer.h"

/* the following headers have been included within gnocl.h */
#include <string.h>
#include <assert.h>


/*****************
 * relocated from cairo.c
 * used to draw splash screen
 ******************************/

static gchar *dash;

/* Key for automated pixbuf updating and destruction */
static const cairo_user_data_key_t pixbuf_key;

cairo_t   *gnoclPixbufCairoCreate ( GdkPixbuf *pixbuf );
GdkPixbuf *gnoclPixbufCairoDestroy ( cairo_t   *cr, gboolean   create_new_pixbuf );

/* Key for automated pixbuf updating and destruction */
static const cairo_user_data_key_t pixbuf_key;


/**
\brief	This function will initialize new cairo context with contents of
		@pixbuf. You can then draw using returned context. When finished
		drawing, you must call gnoclPixbufCairoDestroy() or your pixbuf
		will not be updated with new contents!

 	Return value: New cairo_t context. When you're done with it, call
 	gnoclPixbufCairoDestroy() to update your pixbuf and free memory.
**/
cairo_t * gnoclPixbufCairoCreate ( GdkPixbuf *pixbuf )
{

	gint width;					/* Width of both pixbuf and surface */
	gint height;    			/* Height of both pixbuf and surface */
	gint p_stride;  			/* Pixbuf stride value */
	gint p_n_channels; 			/* RGB -> 3, RGBA -> 4 */
	gint s_stride;     			/* Surface stride value */
	guchar  *p_pixels;  		/* Pixbuf's pixel data */
	guchar *s_pixels;			/* Surface's pixel data */
	cairo_surface_t *surface;	/* Temporary image surface */
	cairo_t *cr;           		/* Final context */

	g_object_ref ( G_OBJECT ( pixbuf ) );

	/* Inspect input pixbuf and create compatible cairo surface */
	g_object_get ( G_OBJECT ( pixbuf ), "width",           &width,
				   "height",          &height,
				   "rowstride",       &p_stride,
				   "n-channels",      &p_n_channels,
				   "pixels",          &p_pixels,
				   NULL );
	surface = cairo_image_surface_create ( CAIRO_FORMAT_ARGB32, width, height );
	s_stride = cairo_image_surface_get_stride ( surface );
	s_pixels = cairo_image_surface_get_data ( surface );

	/* Copy pixel data from pixbuf to surface */
	while ( height-- )
	{
		gint    i;
		guchar *p_iter = p_pixels,
				*s_iter = s_pixels;

		for ( i = 0; i < width; i++ )
		{
#if G_BYTE_ORDER == G_LITTLE_ENDIAN

			/* Pixbuf:  RGB(A)
			 * Surface: BGRA */
			if ( p_n_channels == 3 )
			{
				s_iter[0] = p_iter[2];
				s_iter[1] = p_iter[1];
				s_iter[2] = p_iter[0];
				s_iter[3] = 0xff;
			}

			else /* p_n_channels == 4 */
			{
				gdouble alpha_factor = p_iter[3] / ( gdouble ) 0xff;

				s_iter[0] = ( guchar ) ( p_iter[2] * alpha_factor + .5 );
				s_iter[1] = ( guchar ) ( p_iter[1] * alpha_factor + .5 );
				s_iter[2] = ( guchar ) ( p_iter[0] * alpha_factor + .5 );
				s_iter[3] =           p_iter[3];
			}

#elif G_BYTE_ORDER == G_BIG_ENDIAN

			/* Pixbuf:  RGB(A)
			 * Surface: ARGB */
			if ( p_n_channels == 3 )
			{
				s_iter[3] = p_iter[2];
				s_iter[2] = p_iter[1];
				s_iter[1] = p_iter[0];
				s_iter[0] = 0xff;
			}

			else /* p_n_channels == 4 */
			{
				gdouble alpha_factor = p_iter[3] / ( gdouble ) 0xff;

				s_iter[3] = ( guchar ) ( p_iter[2] * alpha_factor + .5 );
				s_iter[2] = ( guchar ) ( p_iter[1] * alpha_factor + .5 );
				s_iter[1] = ( guchar ) ( p_iter[0] * alpha_factor + .5 );
				s_iter[0] =           p_iter[3];
			}

#else /* PDP endianness */

			/* Pixbuf:  RGB(A)
			 * Surface: RABG */
			if ( p_n_channels == 3 )
			{
				s_iter[0] = p_iter[0];
				s_iter[1] = 0xff;
				s_iter[2] = p_iter[2];
				s_iter[3] = p_iter[1];
			}

			else /* p_n_channels == 4 */
			{
				gdouble alpha_factor = p_iter[3] / ( gdouble ) 0xff;

				s_iter[0] = ( guchar ) ( p_iter[0] * alpha_factor + .5 );
				s_iter[1] =           p_iter[3];
				s_iter[1] = ( guchar ) ( p_iter[2] * alpha_factor + .5 );
				s_iter[2] = ( guchar ) ( p_iter[1] * alpha_factor + .5 );
			}

#endif
			s_iter += 4;
			p_iter += p_n_channels;
		}

		s_pixels += s_stride;
		p_pixels += p_stride;
	}

	/* Create context and set user data */
	cr = cairo_create ( surface );
	cairo_surface_destroy ( surface );
	cairo_set_user_data ( cr, &pixbuf_key, pixbuf, g_object_unref );

	/* Return context */
	return ( cr );
}

/**

\note	If TRUE, new pixbuf will be created and returned.
		If FALSE, input pixbuf will be updated in place.
\brief	This function will destroy cairo context, created with gnoclPixbufCairoCreate().

	Return value: New or updated GdkPixbuf. You own a new reference on return
	value, so you need to call g_object_unref() on returned pixbuf when you don't
	need it anymore.
**/
GdkPixbuf *gnoclPixbufCairoDestroy ( cairo_t  *cr, gboolean  create_new_pixbuf )
{
	gint width;				/* Width of both pixbuf and surface */
	gint height;    		/* Height of both pixbuf and surface */
	gint p_stride;  		/* Pixbuf stride value */
	gint p_n_channels; 		/* RGB -> 3, RGBA -> 4 */
	gint s_stride;     		/* Surface stride value */
	guchar  *p_pixels;  	/* Pixbuf's pixel data */
	guchar *s_pixels;		/* Surface's pixel data */
	cairo_surface_t *surface;	/* Temporary image surface */
	GdkPixbuf *pixbuf;		/* Pixbuf to be returned */
	GdkPixbuf *tmp_pix;		/* Temporary storage */

	/* Obtain pixbuf to be returned */
	tmp_pix = cairo_get_user_data ( cr, &pixbuf_key );

	if ( create_new_pixbuf )
	{
		pixbuf = gdk_pixbuf_copy ( tmp_pix );
	}

	else
	{
		pixbuf = g_object_ref ( G_OBJECT ( tmp_pix ) );
	}

	/* Obtain surface from where pixel values will be copied */
	surface = cairo_get_target ( cr );

	/* Inspect pixbuf and surface */
	g_object_get ( G_OBJECT ( pixbuf ), "width", &width, "height", &height, "rowstride", &p_stride,
				   "n-channels", &p_n_channels, "pixels", &p_pixels, NULL );
	s_stride = cairo_image_surface_get_stride ( surface );
	s_pixels = cairo_image_surface_get_data ( surface );

	/* Copy pixel data from surface to pixbuf */
	while ( height-- )
	{
		gint    i;
		guchar *p_iter = p_pixels,
				*s_iter = s_pixels;

		for ( i = 0; i < width; i++ )
		{
#if G_BYTE_ORDER == G_LITTLE_ENDIAN
			/* Pixbuf:  RGB(A)
			 * Surface: BGRA */
			gdouble alpha_factor = ( gdouble ) 0xff / s_iter[3];

			p_iter[0] = ( guchar ) ( s_iter[2] * alpha_factor + .5 );
			p_iter[1] = ( guchar ) ( s_iter[1] * alpha_factor + .5 );
			p_iter[2] = ( guchar ) ( s_iter[0] * alpha_factor + .5 );

			if ( p_n_channels == 4 )
				p_iter[3] = s_iter[3];

#elif G_BYTE_ORDER == G_BIG_ENDIAN
			/* Pixbuf:  RGB(A)
			 * Surface: ARGB */
			gdouble alpha_factor = ( gdouble ) 0xff / s_iter[0];

			p_iter[0] = ( guchar ) ( s_iter[1] * alpha_factor + .5 );
			p_iter[1] = ( guchar ) ( s_iter[2] * alpha_factor + .5 );
			p_iter[2] = ( guchar ) ( s_iter[3] * alpha_factor + .5 );

			if ( p_n_channels == 4 )
				p_iter[3] = s_iter[0];

#else /* PDP endianness */
			/* Pixbuf:  RGB(A)
			 * Surface: RABG */
			gdouble alpha_factor = ( gdouble ) 0xff / s_iter[1];

			p_iter[0] = ( guchar ) ( s_iter[0] * alpha_factor + .5 );
			p_iter[1] = ( guchar ) ( s_iter[3] * alpha_factor + .5 );
			p_iter[2] = ( guchar ) ( s_iter[2] * alpha_factor + .5 );

			if ( p_n_channels == 4 )
				p_iter[3] = s_iter[1];

#endif
			s_iter += 4;
			p_iter += p_n_channels;
		}

		s_pixels += s_stride;
		p_pixels += p_stride;
	}

	/* Destroy context */
	cairo_destroy ( cr );

	/* Return pixbuf */
	return ( pixbuf );
}


/**********************************************************************/


PixbufParams *gnoclGetPixBufFromName ( const char *id, Tcl_Interp *interp );
const char *gnoclGetNameFromPixBuf ( GdkPixbuf *pixbuf );
guint32 convertRGBtoPixel ( gchar *clr );
static void set_pixel_color ( GdkPixbuf *pixbuf, int x, int y, guchar red, guchar green, guchar blue, guchar alpha );
//static guchar * create_gradient ( const GdkColor *primary, const GdkColor *secondary, int n_pixels );


/* needs to be public to be accessed by gnocl::inventory */
static GHashTable *name2pixbufList;
static const char idPrefix[] = "::gnocl::_PBUF";

int gnoclOptOrientatePixBuf (	Tcl_Interp *interp,	GnoclOption *opt,	GObject *obj,	Tcl_Obj **ret );

/*
canpixbufs be created and modified using standard properties?
*/
static GnoclOption pixBufOptions[] =
{
	{ "-width", GNOCL_OBJ, "width"}, /* 0 */
	{ "-height", GNOCL_OBJ, "height"}, /* 1 */
	{ "-bitsPerSample", GNOCL_OBJ, "bits-per-sample"}, /* 2 */
	{ "-alpha", GNOCL_OBJ, "has-alpha"}, /* 3 */
	{ "-colorspace", GNOCL_OBJ, "colorspace"}, /* 4 */
	{ "-nChannels", GNOCL_OBJ, "n-channels"}, /* 5*/
	{ "-orientate", GNOCL_OBJ, gnoclOptOrientatePixBuf},

	/* GtkObject Properties */
	{ "-data", GNOCL_OBJ, "", gnoclOptData },

	{ NULL }
};

static const int aIdx  = 0;
static const int bIdx  = 1;
static const int cIdx  = 2;
static const int dIdx  = 3;
static const int eIdx  = 4;
static const int fIdx  = 5;


/**
\note	Code taken from gnome-bg.c
**/
guchar * create_gradient ( const GdkColor *primary, const GdkColor *secondary, int n_pixels )
{
	guchar *result = g_malloc ( n_pixels * 3 );
	int i;

	for ( i = 0; i < n_pixels; ++i )
	{
		double ratio = ( i + 0.5 ) / n_pixels;

		result[3 * i + 0] = ( ( guint16 ) ( primary->red * ( 1 - ratio ) + secondary->red * ratio ) ) >> 8;
		result[3 * i + 1] = ( ( guint16 ) ( primary->green * ( 1 - ratio ) + secondary->green * ratio ) ) >> 8;
		result[3 * i + 2] = ( ( guint16 ) ( primary->blue * ( 1 - ratio ) + secondary->blue * ratio ) ) >> 8;
	}

	return result;
}

/**
\note	Code taken from gnome-bg.c
**/
static void pixbuf_draw_gradient ( GdkPixbuf *pixbuf, gboolean horizontal, GdkColor *primary, GdkColor *secondary, GdkRectangle *rect )
{
	int width;
	int height;
	int rowstride;
	guchar *dst;
	guchar *dst_limit;
	int n_channels = 3;

	rowstride = gdk_pixbuf_get_rowstride ( pixbuf );
	width = rect->width;
	height = rect->height;
	dst = gdk_pixbuf_get_pixels ( pixbuf ) + rect->x * n_channels + rowstride * rect->y;
	dst_limit = dst + height * rowstride;

	if ( horizontal )
	{
		guchar *gradient = create_gradient ( primary, secondary, width );
		int copy_bytes_per_row = width * n_channels;
		int i;

		for ( i = 0; i < height; i++ )
		{
			guchar *d;
			d = dst + rowstride * i;
			memcpy ( d, gradient, copy_bytes_per_row );
		}

		g_free ( gradient );
	}

	else
	{
		guchar *gb, *gradient;
		int i;

		gradient = create_gradient ( primary, secondary, height );

		for ( i = 0; i < height; i++ )
		{
			int j;
			guchar *d;

			d = dst + rowstride * i;
			gb = gradient + n_channels * i;

			for ( j = width; j > 0; j-- )
			{
				int k;

				for ( k = 0; k < n_channels; k++ )
				{
					* ( d++ ) = gb[k];
				}
			}
		}

		g_free ( gradient );
	}
}

/**
\note	Code taken from gnome-bg.c
**/
static void pixbuf_blend ( GdkPixbuf *src, GdkPixbuf *dest, int src_x, int src_y, int src_width, int src_height, int dest_x, int dest_y, double	alpha )
{
	int dest_width = gdk_pixbuf_get_width ( dest );
	int dest_height = gdk_pixbuf_get_height ( dest );
	int offset_x = dest_x - src_x;
	int offset_y = dest_y - src_y;

	if ( src_width < 0 )
		src_width = gdk_pixbuf_get_width ( src );

	if ( src_height < 0 )
		src_height = gdk_pixbuf_get_height ( src );

	if ( dest_x < 0 )
		dest_x = 0;

	if ( dest_y < 0 )
		dest_y = 0;

	if ( dest_x + src_width > dest_width )
	{
		src_width = dest_width - dest_x;
	}

	if ( dest_y + src_height > dest_height )
	{
		src_height = dest_height - dest_y;
	}

	gdk_pixbuf_composite ( src, dest,
						   dest_x, dest_y,
						   src_width, src_height,
						   offset_x, offset_y,
						   1, 1, GDK_INTERP_NEAREST,
						   alpha * 0xFF + 0.5 );
}

/**
\note	Code taken from gnome-bg.c
**/
static void pixbuf_tile ( GdkPixbuf *src, GdkPixbuf *dest )
{
	int x, y;
	int tile_width, tile_height;
	int dest_width = gdk_pixbuf_get_width ( dest );
	int dest_height = gdk_pixbuf_get_height ( dest );

	tile_width = gdk_pixbuf_get_width ( src );
	tile_height = gdk_pixbuf_get_height ( src );

	for ( y = 0; y < dest_height; y += tile_height )
	{
		for ( x = 0; x < dest_width; x += tile_width )
		{
			pixbuf_blend ( src, dest, 0, 0,
						   tile_width, tile_height, x, y, 1.0 );
		}
	}
}

/**
\note	Code taken from gnome-bg.c
**/
static GdkPixbuf * pixbuf_clip_to_fit ( GdkPixbuf *src, int max_width, int max_height )
{
	int src_width, src_height;
	int w, h;
	int src_x, src_y;
	GdkPixbuf *pixbuf;

	src_width = gdk_pixbuf_get_width ( src );
	src_height = gdk_pixbuf_get_height ( src );

	if ( src_width < max_width && src_height < max_height )
		return g_object_ref ( src );

	w = MIN ( src_width, max_width );
	h = MIN ( src_height, max_height );

	pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB,
							  gdk_pixbuf_get_has_alpha ( src ),
							  8, w, h );

	src_x = ( src_width - w ) / 2;
	src_y = ( src_height - h ) / 2;
	gdk_pixbuf_copy_area ( src,
						   src_x, src_y,
						   w, h,
						   pixbuf,
						   0, 0 );
	return pixbuf;
}


/**
\brief  Takes an existing pixbuf and checks for the presence of an
		associated "orientation" option, which may be provided by the
		jpeg loader (which reads the exif orientation tag) or the tiff
		loader (which reads the tiff orientation tag, and compensates it
		for the partial transforms performed by libtiff). If an
		orientation option/tag is present, the appropriate transform
		will be performed so that the pixbuf is oriented correctly.

**/
int gnoclOptOrientatePixBuf (	Tcl_Interp *interp,	GnoclOption *opt,	GObject *obj,	Tcl_Obj **ret )
{

	//GdkPixbuf * gdk_pixbuf_apply_embedded_orientation (GdkPixbuf *src);
}

/**
\brief
**/
void gnoclGetPixBufList ( GList **list )
{
	g_hash_table_foreach ( name2pixbufList, hash_to_list, list );
}

/**
\brief  Rotate a pixbuf through an arbitrary angle (degrees).
\author
\date   15/Feb/2010
\since  0.9.94
\note   Adaption of:
     GdkPixbuf * gdk_pixbuf_rotate(GdkPixbuf *pixbuf, double angle, int acolor)

     The returned image has the same size as the original, but the
     pixbuf envelope is increased to accomodate the rotated original
     (e.g. a 100x100 pixbuf rotated 45 deg. needs a 142x142 pixbuf).

     Pixels added around the rotated image have all RGB values = acolor.   //  v.2.17

     Angle is in degrees. Positive direction is clockwise.
     Pixbuf must have 8 bits per channel and 3 or 4 channels.
     Loss of resolution is about 1/2 pixel.
     Speed is about 18 million pixels/sec. on my 2.67 GHz CPU.             //  v.3.2

     NULL is returned if the function fails for one of the following:
         - pixbuf not 8 bits/channel or < 3 channels
         - unable to create output pixbuf (lack of memory?)

     Algorithm:
         create output pixbuf big enough for rotated input pixbuf
         compute coefficients for affine transform
         loop all output pixels
            get next output pixel (px2,py2)
            convert to input pixel (px1,py1) using affine transform        //  v.3.2
            if outside of pixmap
               output pixel = black
               continue
            for 4 input pixels based at (px0,py0) = (int(px1),int(py1))
               compute overlap (0 to 1) with (px1,py1)
               sum RGB values * overlap
            output aggregate RGB to pixel (px2,py2)
\see    http://kornelix.squarespace.com

    Note: Not really certain what the acolor variable actually does.

**/
GdkPixbuf * pixbufRotate ( GdkPixbuf *pixbuf1, double angle, int acolor )
{

	g_print ( "%s 1 %f\n", __FUNCTION__, angle );

	/* 3 RGB values, 0-255 each */
	typedef unsigned char  *pixel;

	GdkPixbuf *pixbuf2;
	GdkColorspace color;

	int nch, nbits, alpha;
	int ww1, hh1, rs1, ww2, hh2, rs2;
	int px2, py2, px0, py0;
	pixel ppix1, ppix2, pix0, pix1, pix2, pix3;
	double px1, py1;
	double f0, f1, f2, f3, red, green, blue;
	double a, b, d, e, ww15, hh15, ww25, hh25;
	double pi = 3.141593;

	nch = gdk_pixbuf_get_n_channels ( pixbuf1 );
	nbits = gdk_pixbuf_get_bits_per_sample ( pixbuf1 );

	/* must have 3+ channels (colors) */
	if ( nch < 3 ) return 0;

	/* must be 8 bits per channel */
	if ( nbits != 8 ) return 0;


	g_print ( "%s 2\n", __FUNCTION__ );


	/* get input pixbuf1 attributes */
	color = gdk_pixbuf_get_colorspace ( pixbuf1 );
	alpha = gdk_pixbuf_get_has_alpha ( pixbuf1 );
	ww1 = gdk_pixbuf_get_width ( pixbuf1 );
	hh1 = gdk_pixbuf_get_height ( pixbuf1 );
	rs1 = gdk_pixbuf_get_rowstride ( pixbuf1 );

	/* normalize, -180 to +180 */
	while ( angle < -180 ) angle += 360;

	while ( angle > 180 ) angle -= 360;

	/* radians, -pi to +pi */
	angle = angle * pi / 180;

	/*  bugfix 0.01 >> 0.001   v.2.1 */
	if ( fabs ( angle ) < 0.001 )
	{
		/* angle is zero within my precision */
		pixbuf2 = gdk_pixbuf_copy ( pixbuf1 );
		return pixbuf2;
	}

	/* rectangle containing rotated image */
	ww2 = ww1 * fabs ( cos ( angle ) ) + hh1 * fabs ( sin ( angle ) );
	hh2 = ww1 * fabs ( sin ( angle ) ) + hh1 * fabs ( cos ( angle ) );

	/* create output pixbuf2 */
	pixbuf2 = gdk_pixbuf_new ( color, alpha, nbits, ww2, hh2 );




	if ( ! pixbuf2 ) return 0;

	rs2 = gdk_pixbuf_get_rowstride ( pixbuf2 );

	/* input pixel array */
	ppix1 = gdk_pixbuf_get_pixels ( pixbuf1 );

	/* output pixel array */
	ppix2 = gdk_pixbuf_get_pixels ( pixbuf2 );

	ww15 = 0.5 * ww1;
	hh15 = 0.5 * hh1;
	ww25 = 0.5 * ww2;
	hh25 = 0.5 * hh2;

	/* affine transform coefficients   v.3.2 */
	a = cos ( angle );
	b = sin ( angle );
	d = - sin ( angle );
	e = cos ( angle );

	/* loop through output pixels */
	for ( py2 = 0; py2 < hh2; py2++ )
		for ( px2 = 0; px2 < ww2; px2++ )
		{
			/* (px1,py1) = corresponding       v.3.2 */
			px1 = a * ( px2 - ww25 ) + b * ( py2 - hh25 ) + ww15;

			/* point within input pixels */
			py1 = d * ( px2 - ww25 ) + e * ( py2 - hh25 ) + hh15;

			/* pixel containing (px1,py1) */
			px0 = px1;
			py0 = py1;

			/* if outside input pixel array */
			if ( px1 < 0 || px0 >= ww1 - 1 || py1 < 0 || py0 >= hh1 - 1 )
			{
				/* output is acolor    v.2.17 */
				pix2 = ppix2 + py2 * rs2 + px2 * nch;
				pix2[0] = pix2[1] = pix2[2] = acolor;
				continue;
			}

			/* 4 input pixels based at (px0,py0) */
			pix0 = ppix1 + py0 * rs1 + px0 * nch;
			pix1 = pix0 + rs1;
			pix2 = pix0 + nch;
			pix3 = pix0 + rs1 + nch;

			/* overlap of (px1,py1) */
			f0 = ( px0 + 1 - px1 ) * ( py0 + 1 - py1 );

			/* in each of the 4 pixels */
			f1 = ( px0 + 1 - px1 ) * ( py1 - py0 );
			f2 = ( px1 - px0 ) * ( py0 + 1 - py1 );
			f3 = ( px1 - px0 ) * ( py1 - py0 );

			/* sum the weighted inputs */
			red =   f0 * pix0[0] + f1 * pix1[0] + f2 * pix2[0] + f3 * pix3[0];
			green = f0 * pix0[1] + f1 * pix1[1] + f2 * pix2[1] + f3 * pix3[1];
			blue =  f0 * pix0[2] + f1 * pix1[2] + f2 * pix2[2] + f3 * pix3[2];

			/* avoid acolor in image     v.2.17 */
			if ( red == acolor && green == acolor && blue == acolor )
			{
				if ( blue == 0 ) blue = 1;
				else blue--;
			}

			/* output pixel */
			pix2 = ppix2 + py2 * rs2 + px2 * nch;
			pix2[0] = red;
			pix2[1] = green;
			pix2[2] = blue;
		}

	return pixbuf2;
}

/**
\brief
\note       From module parseoptions.c
**/
static int getShortValue ( Tcl_Interp *interp, Tcl_Obj *list, int idx, int *p )
{
	int val;
	Tcl_Obj *tp;

	if ( Tcl_ListObjIndex ( interp, list, idx, &tp ) != TCL_OK  )
		return TCL_ERROR;

	if ( Tcl_GetIntFromObj ( NULL, tp, &val ) != TCL_OK )
	{
		double d;

		if ( Tcl_GetDoubleFromObj ( NULL, tp, &d ) != TCL_OK )
		{
			Tcl_AppendResult ( interp,
							   "expected integer or double, but got \"",
							   Tcl_GetString ( tp ), "\"", NULL );
			return TCL_ERROR;
		}

		val = d * 0xFFFF;
	}

	if ( val < .0 || val > 0xFFFF )
	{
		Tcl_SetResult ( interp, "color value must be between 0 and 65535",
						TCL_STATIC );
		return TCL_ERROR;
	}

	*p = val;

	return TCL_OK;
}

/**
\brief
\author     Tadej Borov≈°ak
\date       14/Feb/2010
\note       gdk_color_parse() will only fill red, green and blue elements
             of GdkColor. In order to fill pixel value, you'll need to
             allocate your color using gdk_colormap_alloc_color().
             But event if you do this, pixel value is not what you want
             in this case, since pixel value is only meaningful in context
             of your underlying windowing system.

**/
guint32 convertRGBtoPixel ( gchar *clr )
{

	GdkColor color;
	guint32 pixel;

	/* Conversion factor from 16-bit color to 8-bit color (0xff / 0xffff) */
	const gdouble f = 0.00389105;

	/* create the colour from the supplied string, added by WJG */
	gdk_color_parse ( clr, &color );

	/* fill with colour */
	pixel = ( ( ( guint ) ( color.red   * f + 0.5 ) ) << 24 ) | /* R */
			( ( ( guint ) ( color.green * f + 0.5 ) ) << 16 ) | /* G */
			( ( ( guint ) ( color.blue  * f + 0.5 ) ) <<  8 ) | /* B */
			( 0xff <<  0 );                                     /* A */

#ifdef DEBUG_PIXBUF
	printf ( "pixel = %d\n", pixel );
#endif
	return pixel;
}


/**
\brief
\note       From module parseoptions.c
**/
static int getRGBA ( Tcl_Interp *interp, Tcl_Obj *obj, int *r, int *g, int *b, int *a )
{
	int no;

	if ( Tcl_ListObjLength ( interp, obj, &no ) != TCL_OK  || no < 0 || no > 4 )
	{
		Tcl_SetResult ( interp, "color must be either \"name\" or a list "
						"consisting of \"name alpha\", \"r g b\", or \"r g b alpha\"",
						TCL_STATIC );
		return TCL_ERROR;
	}

	if ( no == 0 ) /* transparent */
	{
		*r = *g = *b = *a = 0;
	}

	else if ( no < 3 )
	{
		Tcl_Obj *tp = obj;
		GdkColor color;

		if ( no == 2 )
		{
			if ( Tcl_ListObjIndex ( interp, obj, 0, &tp ) != TCL_OK )
				return TCL_ERROR;
		}

		/* take as string and reformat as a GdkColor structure */

		if ( gdk_color_parse ( Tcl_GetString ( tp ), &color ) == 0 )
		{
			Tcl_AppendResult ( interp, "unknown color \"", Tcl_GetString ( obj ), "\".", ( char * ) NULL );
			return TCL_ERROR;
		}

		*r = color.red;
		*g = color.green;
		*b = color.blue;

		if ( no == 2 )
		{
			if ( getShortValue ( interp, obj, 1, a ) != TCL_OK )
				return TCL_ERROR;
		}

		else
			*a = 0xFFFF;
	}

	else
	{
		if ( getShortValue ( interp, obj, 0, r ) != TCL_OK
				|| getShortValue ( interp, obj, 1, g ) != TCL_OK
				|| getShortValue ( interp, obj, 2, b ) != TCL_OK )
			return TCL_ERROR;

		if ( no == 4 )
		{
			if ( getShortValue ( interp, obj, 3, a ) != TCL_OK )
				return TCL_ERROR;
		}

		else
			*a = 0xFFFF;
	}

	return TCL_OK;
}

/**
\brief      Take colour values from a string format and assign them to
            location addressed by pointer *color.
**/
static int getGdkColor ( Tcl_Interp *interp, Tcl_Obj *obj, GdkColor *color )
{
	int r, g, b, a;

	if ( getRGBA ( interp, obj, &r, &g, &b, &a ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	/* TODO? if a != 0xFFFF: alpha not supported? */
	color->red = r;

	color->green = g;

	color->blue = b;

	return TCL_OK;
}

/**
\brief      Function associated with the pixbufs.
**/
int pixBufFunc ( ClientData data, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	listParameters ( objc, objv, "pixBufFunc" );
#endif

	//GdkPixbuf *pixbuf;
	//GdkPixbuf *dest->pixbuf;

	PixbufParams *para, *dest;

	para = ( PixbufParams * ) data;
	dest = g_new ( PixbufParams, 1 );


	//pixbuf = GDK_PIXBUF ( data );

	static const char *cmds[] =
	{
		"copy", "delete", "configure", "duplicate",
		"cget", "draw", "class",
		"fill", "flood", "save", "turn",
		"flip", "rotate", "composite",
		"subpixbuf",
		"saturation", "pixelate", "colorize",
		"getPixel", "setPixel", "info", "filter",
		"scale", "resize", "addAlpha",
		NULL
	};

	enum cmdIdx
	{
		CopyIdx, DeleteIdx, ConfigureIdx, DuplicateIdx,
		CgetIdx, DrawIdx, ClassIdx,
		FillIdx, FloodIdx, SaveIdx, TurnIdx,
		FlipIdx, RotateIdx, CompositeIdx,
		SubPixBufIdx,
		SaturationIdx, PixelateIdx, ColorizeIdx,
		GetPixelIdx, SetPixelIdx, InfoIdx, FilterIdx,
		ScaleIdx, ResizeIdx, AddAlphaIdx
	};

	int idx;

	if ( objc < 2 )
	{
		Tcl_WrongNumArgs ( interp, 1, objv, "command" );
		return TCL_ERROR;
	}

	if ( Tcl_GetIndexFromObj ( interp, objv[1], cmds, "command", TCL_EXACT, &idx ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	switch ( idx )
	{
		case FloodIdx:
			{

				g_print ( "FloodIdx\n" );

				guint x, y;

				sscanf ( Tcl_GetString ( objv[2] ), "%u", &x );
				sscanf ( Tcl_GetString ( objv[3] ), "%u", &x );


				//void gdk_pixbuf_flood_fill ( GdkPixbuf *pixbuf, guint fill_color, guint x, guint y )
				//gdk_pixbuf_flood_fill ( para->pixbuf, convertRGBtoPixel (Tcl_GetString ( objv[4] )) , x, y );
				gdk_pixbuf_flood_fill ( para->pixbuf, 0x0000ff00 , x, y );
			}
			break;
		case AddAlphaIdx:
			{
				/*
				GdkPixbuf * gdk_pixbuf_add_alpha (const GdkPixbuf *pixbuf, gboolean substitute_color, guchar r, guchar g, guchar b);
				*/
			}
			break;
		case ScaleIdx:
			{

				GdkInterpType interp_type;
				interp_type = GDK_INTERP_BILINEAR;
				float xScale, yScale;
				gint w, h, i, resizeIdx;
				float dest_width, dest_height;

				static char *resizeOptions[] =
				{
					"-height", "-width",
					NULL
				};

				static enum  optsIdx
				{
					heightIdx, widthIdx
				};

				xScale = -1;
				yScale = -1;

				if ( objc == 3 )
				{

					sscanf ( Tcl_GetString ( objv[2] ), "%f", &xScale );
					yScale = xScale;

				}

				/* parse all the options */
				i = 2;

				while ( i < objc )
				{
					getIdx ( resizeOptions, Tcl_GetString ( objv[i] ), &resizeIdx );

					switch ( resizeIdx )
					{
						case heightIdx:
							{
#ifdef DEBUG_PIXBUF
								g_print ( "height\n" );
#endif

								sscanf ( Tcl_GetString ( objv[i+1] ), "%f", &yScale );

							} break;
						case widthIdx:
							{
#ifdef DEBUG_PIXBUF
								g_print ( "width\n" );
#endif
								sscanf ( Tcl_GetString ( objv[i+1] ), "%f", &xScale );
							} break;
						default:
							{
							}
					}

					i += 2;
				}

				if ( xScale == -1 )
				{
					xScale = yScale;

				}

				if ( yScale == -1 )
				{
					yScale = xScale;
				}


				if ( xScale == -1 && yScale == -1 )
				{
					xScale = 1;
					yScale = 1;
				}

				w = gdk_pixbuf_get_width ( para->pixbuf );
				h = gdk_pixbuf_get_height ( para->pixbuf );

				dest_width = ( float ) w * xScale;
				dest_height = ( float ) h * yScale;

#ifdef DEBUG_PIXBUF
				g_print ( "i = %d dest_width, dest_height = %f %f\n", i, dest_width, dest_height );
#endif
				dest->pixbuf = gdk_pixbuf_scale_simple (  para->pixbuf, ( int ) dest_width, ( int ) dest_height, interp_type );

				para->pixbuf = dest->pixbuf;
				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );
				return gnoclRegisterPixBuf ( interp, dest->pixbuf, pixBufFunc );
			}
			break;
		case ResizeIdx:
			{

				GdkInterpType interp_type;
				interp_type = GDK_INTERP_BILINEAR;
				gint dest_width, dest_height;
				gint i, w, h;
				gint resizeIdx;

				dest_width = -1 ;
				dest_height = -1;

				static char *resizeOptions[] =
				{
					"-height", "-width",
					NULL
				};

				static enum  optsIdx
				{
					heightIdx, widthIdx
				};

				/* parse all the options */
				i = 2;

				while ( i < objc )
				{

					getIdx ( resizeOptions, Tcl_GetString ( objv[i] ), &resizeIdx );

					switch ( resizeIdx )
					{
						case heightIdx:
							{
#ifdef DEBUG_PIXBUF
								g_print ( "height\n" );
#endif

								sscanf ( Tcl_GetString ( objv[i+1] ), "%d", &dest_height );

							} break;
						case widthIdx:
							{
#ifdef DEBUG_PIXBUF
								g_print ( "width\n" );
#endif
								sscanf ( Tcl_GetString ( objv[i+1] ), "%d", &dest_width );
							} break;
						default:
							{
							}
					}

					i += 2;
				}

				//return TCL_OK;

				//i = sscanf ( Tcl_GetString ( objv[2] ), "%d %d", &dest_width, &dest_height );

				if ( dest_width == -1 &&  dest_height == -1 )
				{

#ifdef DEBUG_PIXBUF
					g_print ( "plain copy\n" );
#endif

					dest->pixbuf = gdk_pixbuf_copy ( para->pixbuf );

					/* need to create a new para here */

					para->pixbuf = dest->pixbuf;
					return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );
					return gnoclRegisterPixBuf ( interp, dest->pixbuf, pixBufFunc );
				}

				if ( dest_height == -1 )
				{
					/* scale height in proportion to width */
					w = gdk_pixbuf_get_width ( para->pixbuf );
					h = gdk_pixbuf_get_height ( para->pixbuf );

					dest_height = dest_width * h / w;
				}

				if ( dest_width == -1 )
				{
					/* scale height in proportion to width */
					w = gdk_pixbuf_get_width ( para->pixbuf );
					h = gdk_pixbuf_get_height ( para->pixbuf );

					dest_width = dest_height * w / h;
				}

				dest->pixbuf = gdk_pixbuf_scale_simple (  para->pixbuf, dest_width, dest_height, interp_type );

				para->pixbuf = dest->pixbuf;

				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );
				return gnoclRegisterPixBuf ( interp, dest->pixbuf, pixBufFunc );
			}
		case DuplicateIdx:
			{

				dest->pixbuf = gdk_pixbuf_copy ( para->pixbuf );

				para->pixbuf = dest->pixbuf;

				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );
				return gnoclRegisterPixBuf ( interp, dest->pixbuf, pixBufFunc );
			}
			break;
		case FilterIdx:
			{
				gnoclPixBufFilters ( interp, para->pixbuf ,  objc, objv );
			}
			break;
		case InfoIdx:
			{
				gchar str[32];
				gint w, h, a, bps, n;
				w = gdk_pixbuf_get_width ( para->pixbuf );
				h = gdk_pixbuf_get_height ( para->pixbuf );
				a = gdk_pixbuf_get_has_alpha ( para->pixbuf );
				bps = gdk_pixbuf_get_bits_per_sample ( para->pixbuf );
				n = gdk_pixbuf_get_n_channels ( para->pixbuf );

				sprintf ( str, "%d %d %d %d %d", w, h, a, bps, n );

				Tcl_SetResult ( interp, str, TCL_STATIC );

			}
			break;
		case SetPixelIdx:
			{

				gint x, y, w, h;
				guchar r, g, b, a;

				/* set pixel location */
				sscanf ( Tcl_GetString ( objv[2] ), "%d %d", &x, &y );
				sscanf ( Tcl_GetString ( objv[3] ),  "%d %d %d %d", &r, &g, &b , &a );

				w = gdk_pixbuf_get_width ( para->pixbuf );
				h = gdk_pixbuf_get_height ( para->pixbuf );

				if ( 0 )
				{
					GdkColor color;

					if ( getGdkColor ( interp, Tcl_GetString ( objv[3] ), &color ) != TCL_OK )
					{
						return TCL_ERROR;
					}
				}

				//set_pixel_color ( pixbuf, x, y , r, g, b, a );
#ifdef DEBUG_PIXBUF
				g_printf ( "x =%d y =%d w =%d h =%d\n", x, y, w, h );
				g_printf ( "r =%d g =%d b =%d a =%d\n", r, g, b, a );
#endif

				/* error checking */
				if ( x < 0 || x > gdk_pixbuf_get_width ( para->pixbuf )  )
				{
					//   return FALSE;
				}

				if ( y < 0 || y > gdk_pixbuf_get_height ( para->pixbuf )  )
				{
					//  return FALSE;
				}

				gdk_pixbuf_set_pixel ( para->pixbuf, convertRGBtoPixel ( Tcl_GetString ( objv[3] ) ), x, y );

			}
			break;

		case GetPixelIdx:
			{

				gint x, y;
				guchar r, g, b, a;
				double R, G, B, A;

				gchar str[24];

				/* get pixel location */
				sscanf ( Tcl_GetString ( objv[2] ), "%d %d", &x, &y );
#ifdef DEBUG_PIXBUF
				g_printf ( "pos = %d %d\n", x, y );
#endif
				gdk_pixbuf_get_pixel ( para->pixbuf, x, y , &r, &g, &b, &a );


				/* convert int to decimal float */

				R = ( double ) r / 255;
				G = ( double ) g / 255;
				B = ( double ) b / 255;
				A = ( double ) a / 255;

				sprintf ( str, "%f %f %f %f", R, G, B, A );

				Tcl_SetResult ( interp, str, TCL_STATIC );

			}
			break;
		case PixelateIdx:
			{

				double saturation;

				/* simplest way to get the a duplicate buffer to paste into */
				dest->pixbuf = gdk_pixbuf_copy ( para->pixbuf );

				if ( 0 )
				{
					if ( Tcl_GetDoubleFromObj ( interp, objv[2], &saturation ) != TCL_OK )
					{
						Tcl_SetResult ( interp, "Invalid value set for saturation, must be a float.\n", TCL_STATIC );
						return TCL_ERROR;
					}
				}

				gdk_pixbuf_saturate_and_pixelate ( para->pixbuf, dest->pixbuf, 1.0, TRUE );

				para->pixbuf = dest->pixbuf;
				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );
				return gnoclRegisterPixBuf ( interp, dest->pixbuf, pixBufFunc );

			}
			break;
		case SaturationIdx:
			{

				double saturation;

				/* simplest way to get the a duplicate buffer to paste into */
				dest->pixbuf = gdk_pixbuf_copy ( para->pixbuf );

				if ( Tcl_GetDoubleFromObj ( interp, objv[2], &saturation ) != TCL_OK )
				{
					Tcl_SetResult ( interp, "Invalid value set for saturation, must be a float.\n", TCL_STATIC );
					return TCL_ERROR;
				}

				gdk_pixbuf_saturate_and_pixelate ( para->pixbuf, dest->pixbuf, saturation, FALSE );

				para->pixbuf = dest->pixbuf;
				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );
				return gnoclRegisterPixBuf ( interp, dest->pixbuf, pixBufFunc );

			}
			break;
		case CopyIdx:
			{
#ifdef DEBUG_PIXBUF
				g_print ( "CopyIdx %s\n", Tcl_GetString ( objv[2] ) );
#endif

				int src_x;
				int src_y;
				int width;
				int height;

				dest->pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB, FALSE, 8, width, height );

				/* if no string is passed make a simple duplicate */
				if ( objc == 2 )
				{
#ifdef DEBUG_PIXBUF
					g_print ( "total args %d\n", objc );
#endif
					dest->pixbuf = gdk_pixbuf_copy ( para->pixbuf );
				}

				/* copy as specific region of the pixbuf */
				else
				{

					sscanf ( Tcl_GetString ( objv[2] ), "%d %d %d %d", &src_x, &src_y, &width, &height );
#ifdef DEBUG_PIXBUF
					g_print ( "CopyIdx %d %d %d %d\n", src_x, src_y, width, height );
#endif

					dest->pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB, FALSE, 8, width, height );

					gdk_pixbuf_copy_area ( para->pixbuf, src_x, src_y, width, height, dest->pixbuf, 0, 0 );
				}

				para->pixbuf = dest->pixbuf;
				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );
				return gnoclRegisterPixBuf ( interp, dest->pixbuf, pixBufFunc );

			}
			break;
		case SubPixBufIdx :
			{

				int src_x;
				int src_y;
				int width;
				int height;

				gint i;

				if ( sscanf ( Tcl_GetString ( objv[2] ), "%d %d %d %d", &src_x, &src_y, &width, &height ) != 4 )
				{
					Tcl_SetResult ( interp, "Should be: pixBuf-id subpixBuf {x y w h}./n", TCL_STATIC );

					return TCL_ERROR;
				}

				dest->pixbuf = gdk_pixbuf_new_subpixbuf ( para->pixbuf, src_x, src_y, width, height );

				para->pixbuf = dest->pixbuf;
				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );
				return gnoclRegisterPixBuf ( interp, dest->pixbuf, pixBufFunc );
			}
			break;
		case DeleteIdx:
			{
			}
			break;
		case ConfigureIdx:
			{
			}
			break;
		case CgetIdx:
			{

				static char *cgetOptions[] =
				{
					"-colorSpace", "-nChannels", "-hasAlpha",
					"-bitsPerSample", "-pixels", "-width",
					"-height", "-rowstride", "-key",
					NULL
				};

				static enum  optsIdx
				{
					ColorSpaceIdx, NChannelsIdx, HasAlphaIdx,
					BitsPerSampleIdx, PixelsIdx, WidthIdx,
					HeightIdx, RowStrideIdx, KeyIdx
				};

				int Idx;

				if ( Tcl_GetIndexFromObj ( interp, objv[2], cgetOptions, "option", TCL_EXACT, &Idx ) != TCL_OK )
				{
					return TCL_ERROR;
				}

				switch ( Idx )
				{
					case ColorSpaceIdx:
						{

							/* 05/03/10 only RGB supported */
							gchar *str;

							switch ( gdk_pixbuf_get_colorspace ( para->pixbuf ) )
							{
								case GDK_COLORSPACE_RGB:
									{
										str = "RGB";
									}
									break;
							}

							Tcl_SetObjResult ( interp, Tcl_NewStringObj ( str, -1  ) );

						} break;
					case NChannelsIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_bits_per_sample ( para->pixbuf ) ) );
						} break;
					case HasAlphaIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_has_alpha ( para->pixbuf ) ) );
						} break;
					case BitsPerSampleIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_bits_per_sample ( para->pixbuf ) ) );
						} break;
					case PixelsIdx:
						{
							/* Not terribly certain what this function implies */
							guchar *str;
							str = gdk_pixbuf_get_pixels ( para->pixbuf );

							Tcl_SetObjResult ( interp, Tcl_NewStringObj ( str, -1 ) );
						} break;
					case WidthIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_width ( para->pixbuf ) ) );
						} break;
					case HeightIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_height ( para->pixbuf ) ) );
						} break;
					case RowStrideIdx:
						{
							Tcl_SetObjResult ( interp, Tcl_NewIntObj ( gdk_pixbuf_get_rowstride ( para->pixbuf ) ) );
						} break;
					case KeyIdx:
						{
//const gchar * gdk_pixbuf_get_option (GdkPixbuf *pixbuf,const gchar *key);
						}
						break;
				}
			}
			break;
		case ClassIdx:
			{
				Tcl_SetObjResult ( interp, Tcl_NewStringObj ( "pixbuf", -1 ) );
			}
			break;
		case FillIdx:
			{
				gdk_pixbuf_fill ( para->pixbuf, convertRGBtoPixel ( Tcl_GetString ( objv[2] ) ) );
			}
			break;
		case SaveIdx:
			{
				GError *err;
				gchar *opt, *val;
				gchar *fileType;
				gchar *fileName;
				gchar *parameters;

				/* set a default filetype */
				fileType = NULL;
				fileName = NULL;
				parameters = NULL;

				static char *newOptions[] =
				{
					"-fileName", "-fileType", "-parameters",
					NULL
				};

				static enum  optsIdx
				{
					FileNameIdx, FileTypeIdx, ParametersIdx
				};

				gint i, j;
				int idx;

				for ( i = 2; i < objc; i += 2 )
				{
					j = i + 1;

					opt = Tcl_GetString ( objv[i] );
					val = Tcl_GetString ( objv[j] );

					if ( Tcl_GetIndexFromObj ( interp, objv[i], newOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
					{
						return TCL_ERROR;
					}

					switch ( idx )
					{
						case FileNameIdx:
							{
								//g_printf ( "save file = %s val = %s\n", opt, val );
								err = NULL;
								fileName = val;

								if ( err != NULL )
								{
									g_warning ( err->message );
									g_error_free ( err );
								}
							}
							break;
						case FileTypeIdx:
							{

								GSList *p;

								//g_printf ( "file type = %s val = %s\n", opt, val );

								for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
								{
									//g_printf ( "p = %s\n", gdk_pixbuf_format_get_name ( p->data ) );

									if ( !strcmp ( val, gdk_pixbuf_format_get_name ( p->data ) ) )
									{
										//g_printf ( "ok an acceptable format!\n" );
										fileType = val;
										break;

									}
								}

								if ( fileType == NULL )
								{
									gchar str[64];
									sprintf ( str, "GNOCL ERROR: \"%s\" is not a supported file format.\n", val );
									Tcl_SetResult ( interp, str, TCL_STATIC );
									return TCL_ERROR;
								}

							}
							break;
						case ParametersIdx:
							{
								parameters = val;

							}
							break;
						default:
							{
							}
					}
				}

				//g_printf ( "parameters = %s\n", parameters );


				if ( parameters == NULL )
				{
					gdk_pixbuf_save ( para->pixbuf, fileName, fileType, &err, NULL ) ;
					break;
				}

				/* handle any received parameters */
				if ( parameters != NULL )
				{
					gchar **tmp_array, **iterator;
					gchar *props[10], *vals[10];
					gint  k;

					tmp_array = g_strsplit_set ( parameters, "= ", 0 );
					iterator = tmp_array;
					i = 0;

					/* do the actual split */
					while ( i < g_strv_length ( tmp_array ) / 2 )
					{
						props[i] = *iterator;
						iterator++;

						vals[i]  = *iterator;
						iterator++;

						i++;
					}

					props[i] = NULL; /* First array needs to be NULL terminated */

					gdk_pixbuf_savev ( para->pixbuf, fileName, fileType, props, vals, NULL );
					g_strfreev ( tmp_array );

				}

				else
				{
					/* "plain" save if no parameters set */
					gdk_pixbuf_save ( para->pixbuf, fileName, fileType, &err, NULL );
				}

			} break;
		case TurnIdx:
			{
				/*
				typedef enum {
				    GDK_PIXBUF_ROTATE_NONE             =   0,
				    GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE =  90,
				    GDK_PIXBUF_ROTATE_UPSIDEDOWN       = 180,
				    GDK_PIXBUF_ROTATE_CLOCKWISE        = 270
				} GdkPixbufRotation;
				*/

				int idx;
				int angle;

				angle = 0;

				static char *turnOptions[] =
				{
					"clockwise", "90",
					"counterClockwise", "antiClockwise", "270", "-90",
					"upsideDown", "180", "-180",
					NULL
				};

				static enum  optsIdx
				{
					ClockWiseIdx, _90Idx,
					CounterClockwiseIdx, AntiClockwiseIdx, _270Idx, _minus90Idx,
					UpsideDownIdx, _180Idx, _minus180Idx
				};

				if ( Tcl_GetIndexFromObj ( interp, objv[2], turnOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
				{
					return TCL_ERROR;
				}

				switch ( idx )
				{
					case ClockWiseIdx:
					case _90Idx:
						{
							angle = 90;
						}
						break;

					case CounterClockwiseIdx:
					case AntiClockwiseIdx:
					case _270Idx:
					case _minus90Idx:
						{
							angle = 270;
						}

					case UpsideDownIdx:
					case _180Idx:
					case _minus180Idx:
						{
							angle = 180;
						}
						break;
				}


				/* get rotated copy of the buffer */
				GdkPixbuf *pb;
				pb = gdk_pixbuf_rotate_simple ( para->pixbuf, angle );

				/* clear the parent buffer, then copy accross with composite  */
				gdk_pixbuf_fill ( para->pixbuf, 0x000000000000 );
				gdk_pixbuf_composite ( pb, para->pixbuf, 0, 0,
									   gdk_pixbuf_get_width ( para->pixbuf ),
									   gdk_pixbuf_get_height ( para->pixbuf ),
									   0, 0, 1, 1,
									   GDK_INTERP_BILINEAR, 255 );
				/* free the intermediary pixbuf*/
				g_object_unref ( pb );
			}
			break;
		case FlipIdx:
			{
				GdkPixbuf *pb;

				/* horizontal */
				pb = gdk_pixbuf_flip ( para->pixbuf, TRUE );
				/* vertical */
				pb = gdk_pixbuf_flip ( para->pixbuf, FALSE );

				/* clear the parent buffer, then copy accross with composite  */
				gdk_pixbuf_fill ( para->pixbuf, 0x000000000000 );
				gdk_pixbuf_composite ( pb, para->pixbuf, 0, 0,
									   gdk_pixbuf_get_width ( para->pixbuf ),
									   gdk_pixbuf_get_height ( para->pixbuf ),
									   0, 0, 1, 1,
									   GDK_INTERP_BILINEAR, 255 );
				/* free the intermediary pixbuf*/
				g_object_unref ( pb );

			}
			break;
		case RotateIdx:
			{
				/* todo:
				   associate the named object with the new buffer which will be enlarged.
				   error check, this will not work on svg files
				*/
				g_print ( "RotateIdx 1\n" );
				GdkPixbuf *pb;
				gdouble angle;
				int acolor;
				gchar *name;

				acolor = 255 ; /* default is black */

				//name = gnoclGetNameFromPixBuf ( data );

				g_print ( "RotateIdx 2\n" );

				Tcl_GetDoubleFromObj ( NULL, objv[2], &angle );

				/* only one option */

				if ( !strcmp ( Tcl_GetString ( objv[3] ), "-backgroundColor" ) )
				{
					acolor = Tcl_GetIntFromObj ( NULL, objv[4], &acolor ) ;
				}

				else
				{
					Tcl_SetResult ( interp, "Unknown option. M\n", TCL_STATIC );
					return TCL_ERROR;
				}


				g_print ( "RotateIdx 3\n" );

#ifdef DEBUG_PIXBUF
				g_print ( "Rotate 2 %s %f %s %d\n",
						  name ,
						  angle,
						  Tcl_GetString ( objv[4] ),
						  acolor ); // works ok!
#endif
				/* replace the current buffer with the new buffer */
				pb = pixbufRotate ( para->pixbuf, angle, acolor );

				g_print ( "RotateIdx 4\n" );

				if ( pb == NULL )
				{
					Tcl_SetResult ( interp, "Unable to create pixBuff\n", TCL_STATIC );
					return TCL_ERROR;
				}

				g_print ( "RotateIdx 5\n" );

				para->pixbuf = pb;

				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );
				//return gnoclRegisterPixBuf ( interp, pb, pixBufFunc );
				g_print ( "RotateIdx 6\n" );

			}
			break;
		case CompositeIdx:
			{
				/* this will clearly need parameters sorted from outset */
#ifdef DEBUG_PIXBUF
				g_print ( "CompositeIdx 1\n" );
				g_printf ( "objc = %d\n", objc );
				listParameters ( objc, objv );
#endif
				int compositeIdx;
				static const char *compositeOpts[] =
				{
					"-destX", "-destY",
					"-destWidth", "-destHeight",
					"-offsetX", "-offsetY",
					"-scaleX", "-scaleY",
					"-interpType",
					"-alpha",
					NULL
				};

				enum compIdx
				{
					DestXIdx, DestYIdx,
					DestWidthIdx, DestHeightIdx,
					OffsetXIdx, OffsetYIdx,
					ScaleXIdx, ScaleYIdx,
					InterpTypeIdx,
					AlphaIdx
				};

				/* check the number of arguments */
				if ( objc < 2 )
				{
					Tcl_SetObjResult ( interp, Tcl_NewStringObj ( "ERROR: Wrong number of arguments.", -1  ) );
					return TCL_ERROR;
				}

				GdkPixbuf *src_, *dest;
				PixbufParams *src;


				/* composite options */
				gint dest_x, dest_y;
				gint dest_width, dest_height;
				gdouble offset_x, offset_y;
				gdouble scale_x, scale_y;
				GdkInterpType interp_type;
				gint overall_alpha;


				src = gnoclGetPixBufFromName ( Tcl_GetString ( objv[2] ), interp );
				dest = para->pixbuf;

				/* set some defaults */
				dest_x = 0;
				dest_y = 0;
				dest_width = gdk_pixbuf_get_width ( src->pixbuf );
				dest_height = gdk_pixbuf_get_height ( src->pixbuf );

				offset_x = 0;
				offset_y = 0;
				scale_x = 1;
				scale_y = 1;
				interp_type = GDK_INTERP_BILINEAR;
				overall_alpha = 255;

				gint i; /* counter */

				/* parse all the options */
				i = 3;

				while ( i < objc )
				{

					getIdx ( compositeOpts, Tcl_GetString ( objv[i] ), &compositeIdx );

					switch ( compositeIdx )
					{
						case DestXIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &dest_x );
							}
							break;
						case DestYIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &dest_y );
							}
							break;
						case DestWidthIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &dest_width );
							}
							break;
						case DestHeightIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &dest_height );
							}
							break;
						case OffsetXIdx:
							{
								Tcl_GetDoubleFromObj ( NULL, objv[i+1], &offset_x );
							}
							break;
						case OffsetYIdx:
							{
								Tcl_GetDoubleFromObj ( NULL, objv[i+1], &offset_y );
							}
							break;
						case ScaleXIdx:
							{
								Tcl_GetDoubleFromObj ( NULL, objv[i+1], &scale_x );
							}
							break;
						case ScaleYIdx:
							{
								Tcl_GetDoubleFromObj ( NULL, objv[i+1], &offset_y );
							}
							break;
						case InterpTypeIdx:
							{
								interp_type = GDK_INTERP_BILINEAR;
							}
							break;
						case AlphaIdx:
							{
								Tcl_GetIntFromObj ( NULL, objv[i+1], &overall_alpha );
							}
							break;
						default: {}
					}

					i += 2;
				}

				/* reset values based upon received switches */

				gdk_pixbuf_composite ( src->pixbuf, dest,
									   dest_x, dest_y,
									   dest_width, dest_height,
									   offset_x, offset_y,
									   scale_x, scale_y,
									   interp_type, overall_alpha );
			}
			break;
		case DrawIdx:
			{
				/* draw the pixbuf to a GdkDrawable: ie. a drawing area */
				GtkWidget *widget;
				GdkDrawable *dest;
				gint src_x, src_y;
				gint dest_x, dest_y;
				gint width, height;
				gint x_dither, y_dither;

				/* initialize the values with defaults */
				src_x = 0;
				src_y = 0;
				dest_x = 10;
				dest_y = 10;

				x_dither = 0;
				y_dither = 0;

				/* what size of the buffer has to be drawn */
				width = gdk_pixbuf_get_width ( para->pixbuf );
				height = gdk_pixbuf_get_height ( para->pixbuf );

				widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[2] ), interp );

				if ( widget == NULL )
				{
					return TCL_ERROR;
				}

				dest = GDK_DRAWABLE ( widget->window );

				/* change values based upon switches passed */
				gdk_draw_pixbuf (
					dest,
					gdk_gc_new ( widget->window ),
					para->pixbuf,
					src_x, src_y,
					dest_x, dest_y,
					width,
					height,
					GDK_RGB_DITHER_NONE,
					x_dither, y_dither );

			}
			break;
	}

	return TCL_OK;
}

/**
\brief
\note      "char *" and not "const char *" because of a not very strict
            handling of "const char *" in Tcl e.g. Tcl_CreateObjCommand
*/
char *gnoclGetAutoPixBufId ( void )
{
	static int no = 0;
	/*
	static char buffer[30];
	*/

	char *buffer = g_new ( char, sizeof ( idPrefix ) + 15 );
	strcpy ( buffer, idPrefix );

	/* with namespace, since the Id is also the widget command */
	sprintf ( buffer + sizeof ( idPrefix ) - 1, "%d", ++no );

	return buffer;
}

/**
\brief	Returns pointer to the pixbuf
**/
/* -----------------
   handle widget <-> name mapping
-------------------- */
PixbufParams *gnoclGetPixBufFromName ( const char * id, Tcl_Interp * interp )
{
#ifdef DEBUG_PIXBUF
	g_print ( "%s\n", __FUNCTION__ );
#endif

	PixbufParams *para = NULL;

	//GdkPixbuf *pixbuf = NULL;
	int       n;

	if ( strncmp ( id, idPrefix, sizeof ( idPrefix ) - 1 ) == 0
			&& ( n = atoi ( id + sizeof ( idPrefix ) - 1 ) ) > 0 )
	{
		para = g_hash_table_lookup ( name2pixbufList, GINT_TO_POINTER ( n ) );
	}

	if ( para == NULL && interp != NULL )
	{
		Tcl_AppendResult ( interp, "Unknown pixbuf \"", id, "\".", ( char * ) NULL );
	}

	return para;
}

/**
\brief      Returns the widget name associated with pointer
**/
const char *gnoclGetNameFromPixBuf ( GdkPixbuf * pixbuf )
{
	const char *name = g_object_get_data ( G_OBJECT ( pixbuf ), "gnocl::name" );

	return name;
}

/**
\brief
**/
int gnoclForgetPixBufFromName ( const char * path )
{
	int n = atoi ( path + sizeof ( idPrefix ) - 1 );
	assert ( gnoclGetPixBufFromName ( path, NULL ) );
	assert ( strncmp ( path, idPrefix, sizeof ( idPrefix ) - 1 ) == 0 );
	assert ( n > 0 );

	g_hash_table_remove ( name2pixbufList, GINT_TO_POINTER ( n ) );

	return 0;
}

/**
\brief
**/
static void simpleDestroyFunc ( GdkPixbuf * pixbuf, gpointer data )
{
	const char *name = gnoclGetNameFromPixBuf ( pixbuf );
	gnoclForgetPixBufFromName ( name );
	Tcl_DeleteCommand ( ( Tcl_Interp * ) data, ( char * ) name );
	g_free ( ( char * ) name );
}

/**
\brief
**/
int gnoclMemNameAndPixBuf_ ( const char * path,  PixbufParams *para )
{
	int n ;

	n = atoi ( path + sizeof ( idPrefix ) - 1 );

	assert ( n > 0 );
	assert ( g_hash_table_lookup ( name2pixbufList, GINT_TO_POINTER ( n ) ) == NULL );
	assert ( strncmp ( path, idPrefix, sizeof ( idPrefix ) - 1 ) == 0 );

	/* memorize the name of the widget in the widget */
	g_object_set_data ( G_OBJECT ( para->pixbuf ), "gnocl::name", ( char * ) path );
	g_hash_table_insert ( name2pixbufList, GINT_TO_POINTER ( n ), para );

	return 0;
}

/**
\brief
**/
int gnoclMemNameAndPixBuf ( const char * path,  GdkPixbuf * pixbuf )
{
	int n ;

	n = atoi ( path + sizeof ( idPrefix ) - 1 );

	assert ( n > 0 );
	assert ( g_hash_table_lookup ( name2pixbufList, GINT_TO_POINTER ( n ) ) == NULL );
	assert ( strncmp ( path, idPrefix, sizeof ( idPrefix ) - 1 ) == 0 );

	/* memorize the name of the widget in the widget */
	g_object_set_data ( G_OBJECT ( pixbuf ), "gnocl::name", ( char * ) path );
	g_hash_table_insert ( name2pixbufList, GINT_TO_POINTER ( n ), pixbuf );

	return 0;
}

/**
\brief	Register structure for pixbuf and cairo context
**/
int gnoclRegisterPixBuf_ ( Tcl_Interp * interp, PixbufParams * para, Tcl_ObjCmdProc * proc )
{

	const char *name;

	name = gnoclGetAutoPixBufId();

	/* create cairo context for this pixbuf */
	para->cr = gnoclPixbufCairoCreate ( para->pixbuf );

	gnoclMemNameAndPixBuf_ ( name, para ); //<--- problems here

	//g_signal_connect_after ( G_OBJECT ( pixbuf ), "destroy", G_CALLBACK ( simpleDestroyFunc ), interp );

	if ( proc != NULL )
	{

		Tcl_CreateObjCommand ( interp, ( char * ) name, proc, para, NULL );
	}

	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( name, -1 ) );

	return TCL_OK;
}


/**
\brief
**/
int gnoclRegisterPixBuf ( Tcl_Interp * interp, GdkPixbuf * pixbuf, Tcl_ObjCmdProc * proc )
{

	const char *name;

	name = gnoclGetAutoPixBufId();

	gnoclMemNameAndPixBuf ( name, pixbuf ); //<--- problems here

	//g_signal_connect_after ( G_OBJECT ( pixbuf ), "destroy", G_CALLBACK ( simpleDestroyFunc ), interp );

	if ( proc != NULL )
	{

		Tcl_CreateObjCommand ( interp, ( char * ) name, proc, pixbuf, NULL );
	}

	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( name, -1 ) );

	return TCL_OK;
}

/**
\brief      Convert colour to hexadecimal.
**/
int gnoclRGB2HexCmd ( ClientData data, Tcl_Interp * interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	listParameters ( objc, objv, "gnoclRGB2HexCmd" );
#endif

	GdkColor color;
	gchar str[25];
	gint val;

	getGdkColor ( interp, objv[1], &color );
	sprintf ( str, "#%.2x%.2x%.2x", color.red, color.green, color.blue );

	/* differentiate between 8 / 16 bit colour */
	if ( strcmp ( Tcl_GetString ( objv[2] ), "-8bit" ) == 0 )
	{
		Tcl_GetIntFromObj ( NULL, objv[3], &val );

		/* value of 0 means 16-bit */
		if ( !val )
		{
			color.red *= 257;
			color.green *= 257;
			color.blue *= 257;
			sprintf ( str, "#%.4x%.4x%.4x", color.red, color.green, color.blue );
		}

	}

	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( &str, -1 ) ) ;

	return TCL_OK;
}

/**
\brief      Convert colour 16-bit RGB decimal.
**/
int gnoclClr2RGBCmd ( ClientData data, Tcl_Interp * interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	g_printf ( "gnoclClr2RGBCmd\n" );
	gint _i;


	for ( _i = 0; _i < objc; _i++ )
	{
		g_printf ( "\targ %d = %s\n", _i,  Tcl_GetString ( objv[_i] ) );
	}

#endif

	GdkColor color;
	gchar str[25];
	gint val;

	getGdkColor ( interp, objv[1], &color );

	/* differentiate between 8 / 16 bit colour */
	if ( strcmp ( Tcl_GetString ( objv[2] ), "-8bit" ) == 0 )
	{
		Tcl_GetIntFromObj ( NULL, objv[3], &val );

		if ( !val )
		{

			color.red *= 257;
			color.green *= 257;
			color.blue *= 257;
		}

	}

	sprintf ( str, "%d %d %d", color.red, color.green, color.blue );
	Tcl_SetObjResult ( interp, Tcl_NewStringObj ( &str, -1 ) ) ;

	return TCL_OK;
}


/**
\brief
\author     William J Giddings
\date       17-Jan-2010
\since      0.9.94
**/
int gnoclPixBufCmd ( ClientData data, Tcl_Interp * interp, int objc, Tcl_Obj * const objv[] )
{

#ifdef DEBUG_PIXBUF
	listParameters ( objc, objv, "gnoclpixBufCmd" );
#endif

	GdkPixbuf *pixbuf;
	PixbufParams *para;
	para = g_new ( PixbufParams, 1 );

	/* create new hash table if one does not exist */
	if ( name2pixbufList == NULL )
	{
		name2pixbufList = g_hash_table_new ( g_direct_hash, g_direct_equal );
	}

	static const char *cmd[] =
	{
		"get", "render", "types",
		"description", "license", "licence",
		"extensions", "scalable", "writable",
		"fileInfo", "new", "load",
		"snapshot", "screenshot",
		"logo",
		NULL
	};

	enum cmdIdx
	{
		GetIdx, RenderIdx, TypesIdx,
		DescriptionIdx, LicenseIdx, LicenceIdx,
		ExtensionsIdx, ScalableIdx, WritableIdx,
		FileInfoIdx, NewIdx, LoadIdx,
		SnapshotIdx, ScreenshotIdx,
		LogoIdx
	};

	int cIdx;

	/* set relevant options for commands / sub-commands */
	const int opt1Idx = 0;
	const int opt2Idx = 1;
	const int opt3Idx = 2;

	GnoclOption cmd2Options[] =
	{
		{ "-option1", GNOCL_STRING, "", NULL},
		{ "-option2", GNOCL_STRING, "", NULL },
		{ "-option3", GNOCL_STRING, "", NULL },
		{ NULL }
	};

	/* must have the form <command-name> action objectName <options> */
	/*
		if ( objc <= 1 )
		{
			Tcl_WrongNumArgs ( interp, 1, objv, "command option... " );
			return TCL_ERROR;
		}
	*/
	if ( Tcl_GetIndexFromObj ( interp, objv[1], cmd, "option", TCL_EXACT, &cIdx ) != TCL_OK )
	{
		return TCL_ERROR;
	}

	switch ( cIdx )
	{
		case ScreenshotIdx:
			{
#ifdef DEBUG_PIXBUF
				g_printf ( "objc = %d\n", objc );
#endif
				listParameters ( objc, objv );

				GdkWindow *window_root;

				gint x, y, x2, y2, width, height;
				float cx, cy;
				gint px, py;
				gint rw, rh;
				gint showPointer;

				/* set some defaults */
				x = 0, y = 0;

				/* get necessary values from the root window */
				window_root = gdk_get_default_root_window ();
				gdk_window_get_pointer ( window_root, &px, &py, NULL );
				gdk_window_get_geometry  ( window_root, NULL, NULL, &rw, &rh, NULL );

				if ( objc == 2 )
				{
					/* grab the whole screen */
					width = rw;
					height = rh;

				}

				else if ( objc = 4 )
				{
					/* check sub-command, region pointer -graphic */
					if ( strcmp ( Tcl_GetString ( objv[2] ), "region" ) == 0 )
					{
						sscanf ( Tcl_GetString ( objv[3] ), "%d %d %d %d", &x, &y, &width, &height );

						if ( strcmp ( Tcl_GetString ( objv[4] ), "-pointer" ) == 0 )
						{
							Tcl_GetIntFromObj ( NULL, objv[5], &showPointer );
						}
					}

					if ( strcmp ( Tcl_GetString ( objv[2] ), "pointer" ) == 0 )
					{

						sscanf ( Tcl_GetString ( objv[3] ), "%d %d", &width, &height );
						/* ensure that pointer at the centre of the grab */
						x = px - width / 2;
						y = py - height / 2;

						/* apply some error checks */
						if ( px <= width / 2 )
						{
							x = 0;
						}

						if ( py <= height / 2 )
						{
							y = 0;
						}

						if ( px > rw - width )
						{
							x = px - width + 1;
						}

						if ( py > rh - height )
						{
							y = py - height + 1;
						}
					}

				}

				pixbuf = gdk_pixbuf_get_from_drawable ( NULL, window_root, NULL, x, y , 0, 0, width, height );

				cx = ( float ) px - x;
				cy = ( float ) py - y;

				cairo_t *cr;

				cr = gnoclPixbufCairoCreate ( pixbuf );

				cairo_set_line_width ( cr, 9 );

				//cairo_set_source_rgb ( cr, 0.69, 0.19, 0 );
				cairo_set_source_rgba ( cr, 1.0, 0, 0, 0.25 );

				/* do the drawing */
				cairo_arc ( cr, cx, cy, 20, 0, 2 * G_PI );

				cairo_stroke_preserve ( cr );

				cairo_fill ( cr );

				pixbuf = gnoclPixbufCairoDestroy ( cr, FALSE );

				GdkPixbuf * pointerPB = gdk_pixbuf_new_from_inline ( -1, gnocl_pointer, FALSE, NULL );

				gdk_pixbuf_composite ( pointerPB, pixbuf, px - x, py - y,
									   gdk_pixbuf_get_width ( pointerPB ),
									   gdk_pixbuf_get_height ( pointerPB ),
									   0, 0, 1, 1,
									   GDK_INTERP_BILINEAR, 255 );

				goto registerpixbuf;

			}

			break;
		case SnapshotIdx:
			{
				g_print ( "SS 1 %s\n", Tcl_GetString ( objv[2] ) );
				GtkWidget *widget;
				widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[2] ), interp  );

				/* must be a toplevel */
				widget = gtk_widget_get_toplevel ( widget );

				if ( widget == NULL )
				{
					g_print ( "WARNING\n" );
					return TCL_OK;
				}

				g_print ( "SS 2\n" );

				GdkWindow *window_root;
				GdkRectangle rect;

				window_root = gdk_get_default_root_window ();
				g_print ( "SS 3\n" );

				gdk_window_get_frame_extents ( widget->window, &rect );
				g_print ( "SS 4\n" );

				g_print ( "%d %d %d %d \n", rect.x, rect.y, rect.width, rect.height );

				pixbuf = gdk_pixbuf_get_from_drawable ( NULL, window_root, NULL, rect.x, rect.y, 0, 0, rect.width, rect.height );

				goto registerpixbuf;

			}

			break;
			/* create gnocl_logo from in-line data */
		case LogoIdx:
			{
				pixbuf = gdk_pixbuf_new_from_inline ( -1, gnocl_logo, FALSE, NULL );

				goto registerpixbuf;
			}
			break;
			/* implement template with subcommands and */
		case GetIdx:
			{
				static const char *subCmd[] = { "drawable", "image", "pointer", NULL };
				enum subCmdtIdx { DrawableIdx, ImageIdx, PointerIdx };
				int scIdx;
				Tcl_Obj *tp;

				if ( Tcl_GetIndexFromObj ( interp, objv[2], subCmd, "option", TCL_EXACT, &scIdx ) != TCL_OK )
				{
					return TCL_ERROR;
				}

				/* error handling done within swith case code */
				/*
								if ( objc < 3 )
								{
									return TCL_ERROR;
								}
				*/

				switch ( scIdx )
				{
					case ImageIdx:
					case DrawableIdx:
						{

							/* create a new buffer from the buffer associated with a specific drawable object
							   only works for object already rendered to screen
							*/

							GtkWidget *widget;
							widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[3] ), interp  );

							if ( widget == NULL )
							{
								//widget = gnoclGetPixMapFromName ( Tcl_GetString ( objv[3] ), interp  );
								//if (widget == NULL) {
								return TCL_ERROR;
								//}
							}

							int x, y, width, height, depth;

							gdk_window_get_geometry ( widget->window, &x, &y, &width, &height, &depth );


							pixbuf = gdk_pixbuf_get_from_drawable (
										 NULL,
										 GDK_DRAWABLE ( widget->window ),
										 NULL,
										 0, 0,
										 0, 0,
										 width, height );

							goto registerpixbuf;

						}
						break;

					case PointerIdx:
						{

							if ( objc != 3 )
							{
								return TCL_ERROR;
							}

							g_printf ( "Create a pixbuf from the current pointer\n", Tcl_GetString ( objv[3] ) );

							GdkCursor *cursor;
							GtkWidget *widget;

							widget = gnoclGetWidgetFromName ( Tcl_GetString ( objv[3] ), interp  );
							cursor = gdk_window_get_cursor ( widget->window );
							pixbuf = gdk_cursor_get_image ( cursor );

							goto registerpixbuf;
						}
						break;
				}
			}
			break;
		case RenderIdx:
			{
				/* set relevant options for commands / sub-commands */
				static char *cmd2Options[] = { "-option1", "-option2", "-option3",  NULL};
				static enum  optsIdx { opt1Idx, opt2Idx, opt3Idx };

				/* this one has the options usage:
				    gnocl::<CmdName> command item -option val..
				*/
				int ret;

				ret = compare ( Tcl_GetString ( objv[2] ), cmd2Options );

				switch ( ret )
				{
					case opt1Idx:
						{
							g_printf ( "\t\toption1, parameters = %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
					case opt2Idx:
						{
							g_printf ( "\t\toption2, parameters = %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
					case opt3Idx:
						{
							g_printf ( "\t\toption3, parameters = %s\n", Tcl_GetString ( objv[3] ) );
						}
						break;
				}

			}
			break;
		case TypesIdx:
			{
				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );

				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{

					Tcl_ListObjAppendElement ( interp, resList,
											   Tcl_NewStringObj ( gdk_pixbuf_format_get_name ( p->data ), -1 ) );

				}

				g_free ( p );
				Tcl_SetObjResult ( interp, resList );
			}
			break;
		case DescriptionIdx:
			{
				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );
				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						Tcl_SetObjResult ( interp, Tcl_NewStringObj ( gdk_pixbuf_format_get_description ( p->data ), -1 ) );
					}
				}

				g_free ( p );


			}
			break;
		case LicenceIdx:
		case LicenseIdx:
			{
				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );
				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						Tcl_SetObjResult ( interp, Tcl_NewStringObj ( gdk_pixbuf_format_get_license ( p->data ), -1 ) );
					}
				}

				g_free ( p );

			}
			break;
		case ExtensionsIdx:
			{
				gchar * extensions;
				gchar **extension_list;

				Tcl_Obj *resList;

				resList = Tcl_NewListObj ( 0, NULL );
				GSList *p;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{

						extension_list = gdk_pixbuf_format_get_extensions ( p->data );
						extensions = g_strjoinv ( " ", extension_list );
						g_strfreev ( extension_list );

						Tcl_SetObjResult ( interp, Tcl_NewStringObj ( extensions, -1 ) );
					}
				}

				g_free ( p );

			}
			break;
		case ScalableIdx:
			{
				GSList *p;

				gint res = -1;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						res = gdk_pixbuf_format_is_scalable ( p->data );
					}
				}

				g_free ( p );

				Tcl_SetObjResult ( interp, Tcl_NewIntObj ( res ) ) ;

			}
			break;
		case WritableIdx:
			{
				GSList *p;

				gint res = -1;

				for ( p = gdk_pixbuf_get_formats (); p != NULL; p = p->next )
				{
					if ( !strcmp ( gdk_pixbuf_format_get_name ( p->data ), Tcl_GetString ( objv[2] ) ) )
					{
						res = gdk_pixbuf_format_is_writable ( p->data );
					}
				}

				g_free ( p );

				Tcl_SetObjResult ( interp, Tcl_NewIntObj ( res ) ) ;
			}
			break;
		case FileInfoIdx:
			{

				GdkPixbufFormat *format;
				gint width;
				gint height;
				gchar str[128];

				format = gdk_pixbuf_get_file_info ( Tcl_GetString ( objv[2] ), &width, &height );

				sprintf ( str, "%d %d %s\n", width, height, gdk_pixbuf_format_get_name ( format ) );

				Tcl_SetObjResult ( interp, Tcl_NewStringObj ( &str, -1 ) ) ;

			}
			break;
		case NewIdx:
			{

				gchar *name;
				gint width, height, bps, alpha;
				gchar *opt, *val;
				gint clrspace;

				/* set some default values, then re-assign based upon received values */
				width = 640;
				height = 480;
				bps = 8;
				alpha = 0;
				clrspace = GDK_COLORSPACE_RGB;

				static char *newOptions[] =
				{
					"-width", "-height", "-bitsPerSample", "-colorSpace",
					"-alpha", "-name", "-data",
					NULL
				};

				static enum  optsIdx
				{
					WidthIdx, HeightIdx,
					BitsPerSampleIdx, ColorSpaceIdx,
					AlphaIdx, NameIdx, DataIdx
				};

				gint i, j;
				int idx;

				/* create the buffer,note: only RGB suported */
				//sscanf ( Tcl_GetString ( objv[2] ), "%d %d %d", &width, &height, &bps );
				//pixbuf = gdk_pixbuf_new ( GDK_COLORSPACE_RGB, alpha, bps, width, height );

				/* parse remaining the switches */
				/* set relevant options for commands / sub-commands */

				for ( i = 2; i < objc; i += 2 )
				{
					j = i + 1;

					opt = Tcl_GetString ( objv[i] );
					val = Tcl_GetString ( objv[j] );

					if ( Tcl_GetIndexFromObj ( interp, objv[i], newOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
					{
						return TCL_ERROR;
					}

					switch ( idx )
					{
						case ColorSpaceIdx:
							{
								g_printf ( "GNOCL WARNING: Currently only GDK_COLORSPACE_RGB supported, set by default.\n" );
							}
							break;
						case WidthIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &width );
							}
							break;
						case HeightIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &height );
							}
							break;
						case AlphaIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &alpha );

								if ( alpha != 0 )
								{
									alpha = 1;
								}
							}
							break;
						case BitsPerSampleIdx:
							{
								//g_printf ( "\t\toption1, parameters = %s val = %s\n", opt, val );
								Tcl_GetIntFromObj ( NULL, objv[j], &bps );
							} break;
						case NameIdx:
							{
								g_printf ( "%s Yet to be implemented.", val );
							}
							break;
						case DataIdx:
							{
								g_printf ( "%s Yet to be implemented.", val );;
							}
							break;
						default:
							{
								return TCL_ERROR;
							}
					}

				} /* end of switch parsing */

				pixbuf = gdk_pixbuf_new ( clrspace, alpha, bps, width, height );

				if ( pixbuf == NULL )
				{
					g_print ( "Failed to create pixbuf.\n" );
					return TCL_ERROR;
				}


				para->pixbuf = pixbuf;
				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );


				//goto registerpixbuf;

			} break;
		case LoadIdx:
			{
				// GdkPixbuf * gdk_pixbuf_new_from_file (const char *filename, GError **error);
				gchar *opt, *val;
				gchar *filename;

				static char *newOptions[] =
				{
					"-file", "-width", "-height", "-aspectRatio", "-inLine", NULL
				};

				static enum  optsIdx
				{
					FileIdx, WidthIdx, HeightIdx, AspectRatioIdx, InLineIdx
				};

				gint i, j;
				int idx;

				/* set some default values */
				gint height = 0;
				gint width = 0;
				gint aspect = 1;

				for ( i = 2; i < objc; i += 2 )
				{
					j = i + 1;

					opt = Tcl_GetString ( objv[i] );
					val = Tcl_GetString ( objv[j] );


					if ( Tcl_GetIndexFromObj ( interp, objv[i], newOptions, "command", TCL_EXACT, &idx ) != TCL_OK )
					{
						return TCL_ERROR;
					}

					switch ( idx )
					{
						case InLineIdx:
							{

								/* choose from a list of preset inline graphics */
								static char *inlinePB[] = {"logo", "pointer", NULL };
								static enum  inlinePBIdx { LogoIdx, PointerIdx };
								int idx;

								if ( Tcl_GetIndexFromObj ( interp,  objv[j] , inlinePB, "command", TCL_EXACT, &idx ) != TCL_OK )
								{
									return TCL_ERROR;
								}

								/* determine which built-in graphic to use */
								switch ( idx )
								{
									case LogoIdx:
										{
											pixbuf = gdk_pixbuf_new_from_inline ( -1, gnocl_logo, FALSE, NULL );
										}
									case PointerIdx:
										{
											pixbuf = gdk_pixbuf_new_from_inline ( -1, gnocl_pointer, FALSE, NULL );
										}
								}

								if ( pixbuf == NULL )
								{
									/* add suitable error message */
									gchar *errmsg;
									sprintf ( errmsg, "ERROR: Cannot load inline image \"%s\".\n", Tcl_GetString ( objv[3] ) );
									Tcl_SetResult ( interp, errmsg , TCL_STATIC );
									return TCL_ERROR;
								}

								//goto registerpixbuf;

								para->pixbuf = pixbuf;
								para->fname = filename;
								return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );

							}
							break;

						case HeightIdx:
							{
								height = atoi ( val );
							}
							break;
						case WidthIdx:
							{
								width = atoi ( val );
							}
							break;
						case FileIdx:
							{
								//g_printf ( "load file = %s val = %s\n", opt, val );
								//pixbuf = gdk_pixbuf_new_from_file ( val, NULL );
								filename = val;
							}
							break;
						case AspectRatioIdx:
							{
								/* need error check, its a boolean! */
								aspect = atoi ( val );
							}
							break;
						default:
							{
							}
					}
				}


				if ( height != 0 && width != 0 )
				{
					//printf ( "OK!! height = %d width = %d\n", height, width );
					pixbuf = gdk_pixbuf_new_from_file_at_scale ( filename, width, height, aspect, NULL );
				}

				else
				{
					//printf ( "NOPE!! height = %d width = %d\n", height, width );
					pixbuf = gdk_pixbuf_new_from_file ( val, NULL );
				}

				//goto registerpixbuf;
				para->pixbuf = pixbuf;
				para->fname = filename;
				return gnoclRegisterPixBuf_ ( interp, para, pixBufFunc );

			}
			break;
	}

	return TCL_OK;

registerpixbuf:
	/* keep pointers */
	para->pixbuf = pixbuf;
	return gnoclRegisterPixBuf ( interp, para->pixbuf, pixBufFunc );

}

/**
\brief      Obtain colour and alpha values from an RGBA pixBuf.
\author     William J Giddings
\date       06/03/10
\since      0.9.94
**/
void gdk_pixbuf_get_pixel ( GdkPixbuf * pixbuf, guint x, guint y , guchar * r, guchar * g, guchar * b, guchar * a )
{
	guchar *pixels;
	guchar *p;
	guint w, h;
	guint rowstride, n_channels;

	g_return_if_fail ( GDK_IS_PIXBUF ( pixbuf ) );

	w = gdk_pixbuf_get_width ( pixbuf );
	h = gdk_pixbuf_get_height ( pixbuf );

	if ( w == 0 || h == 0 )
	{
		return;
	}

	if ( x > w || y > h )
	{
		return;
	}

	pixels = gdk_pixbuf_get_pixels ( pixbuf );
	rowstride = gdk_pixbuf_get_rowstride ( pixbuf );
	n_channels = gdk_pixbuf_get_n_channels ( pixbuf );

	p = pixels + x * n_channels + y * rowstride;

	*r = p[0];
	*g = p[1];
	*b = p[2];
	*a = ( n_channels == 4 ) ? p[3] : 0;

}


/*---------------------------------------------------------------------*/

/**
 * gdk_pixbuf_fill:
 * @pixbuf: a #GdkPixbuf
 * @pixel: RGBA pixel to clear to
 *         (0xffffffff is opaque white, 0x00000000 transparent black)
 *
 * Clears a pixbuf to the given RGBA value, converting the RGBA value into
 * the pixbuf's pixel format. The alpha will be ignored if the pixbuf
 * doesn't have an alpha channel.
 *
 **/
/**
\brief      Obtain colour and alpha values from an RGBA pixBuf.
\author     William J Giddings
\date       06/03/10
\since      0.9.94
\note       Adaptation of gdk_pixbuf_fill
**/
void gdk_pixbuf_set_pixel ( GdkPixbuf * pixbuf, guint32 pixel, guint x, guint y )
{
	guchar *pixels;
	guint r, g, b, a;
	guchar *p;
	guint w, h;
	guint rowstride, n_channels;

	g_return_if_fail ( GDK_IS_PIXBUF ( pixbuf ) );

	w = gdk_pixbuf_get_width ( pixbuf );
	h = gdk_pixbuf_get_height ( pixbuf );

	if ( w == 0 || h == 0 )
	{
		return;
	}

	if ( x > w || y > h )
	{
		return;
	}

	pixels = gdk_pixbuf_get_pixels ( pixbuf );
	rowstride = gdk_pixbuf_get_rowstride ( pixbuf );
	n_channels = gdk_pixbuf_get_n_channels ( pixbuf );

	r = ( pixel & 0xff000000 ) >> 24;
	g = ( pixel & 0x00ff0000 ) >> 16;
	b = ( pixel & 0x0000ff00 ) >> 8;
	a = ( pixel & 0x000000ff );

	p = pixels + y * rowstride + x * n_channels;

	switch ( n_channels )
	{
		case 3:
			{
				p[0] = r;
				p[1] = g;
				p[2] = b;
			}
			break;
		case 4:
			{
				p[0] = r;
				p[1] = g;
				p[2] = b;
				p[3] = a;
			}
			break;
		default:
			break;
	}
}

/**
\brief	Draw line to pixbuf using Breseham's algorithm
**/
void gdk_pixbuf_draw_line ( GdkPixbuf *pixbuf, guint32 pixel, gint x1, gint y1, gint x2, gint y2 )
{

	int dx, dy, i, e;
	int incx, incy, inc1, inc2;
	int x, y;

	dx = x2 - x1;
	dy = y2 - y1;

	if ( dx < 0 ) dx = -dx;

	if ( dy < 0 ) dy = -dy;

	incx = 1;

	if ( x2 < x1 ) incx = -1;

	incy = 1;

	if ( y2 < y1 ) incy = -1;

	x = x1;
	y = y1;

	if ( dx > dy )
	{
		gdk_pixbuf_set_pixel ( pixbuf, pixel, x, y );
		e = 2 * dy - dx;
		inc1 = 2 * ( dy - dx );
		inc2 = 2 * dy;

		for ( i = 0; i < dx; i++ )
		{
			if ( e >= 0 )
			{
				y += incy;
				e += inc1;
			}

			else e += inc2;

			x += incx;
			gdk_pixbuf_set_pixel ( pixbuf, pixel, x, y );
		}
	}

	else
	{
		gdk_pixbuf_set_pixel ( pixbuf, pixel, x, y );
		e = 2 * dx - dy;
		inc1 = 2 * ( dx - dy );
		inc2 = 2 * dx;

		for ( i = 0; i < dy; i++ )
		{
			if ( e >= 0 )
			{
				x += incx;
				e += inc1;
			}

			else e += inc2;

			y += incy;
			gdk_pixbuf_set_pixel ( pixbuf, pixel, x, y );
		}
	}

}

/**
\brief	Draw line to pixbuf using Breseham's circle algorithm
**/
void gdk_pixbuf_draw_circle_1 ( GdkPixbuf *pixbuf, guint32 pixel, gint xc, gint yc, gint r, gint fill )
{

	int x, y, p;

	x = 0;
	y = r;

	gdk_pixbuf_set_pixel ( pixbuf, pixel, x, y );


	p = 3 - ( 2 * r );

	for ( x = 0; x <= y; x++ )
	{
		if ( p < 0 )
		{
			y = y;
			p = ( p + ( 4 * x ) + 6 );
		}

		else
		{
			y = y - 1;

			p = p + ( ( 4 * ( x - y ) + 10 ) );
		}

		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + x, yc - y );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc - x, yc - y );

		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + x, yc + y );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc - x, yc + y );

		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + y, yc - x );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc - y, yc - x );

		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + y, yc + x );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc - y, yc + x );

		if ( fill )
		{
			gdk_pixbuf_draw_line ( pixbuf, pixel, xc + x, yc - y, xc - x, yc - y );
			gdk_pixbuf_draw_line ( pixbuf, pixel, xc + x, yc + y, xc - x, yc + y );
			gdk_pixbuf_draw_line ( pixbuf, pixel, xc + y, yc - x, xc - y, yc - x );
			gdk_pixbuf_draw_line ( pixbuf, pixel,  xc + y, yc + x, xc - y, yc + x  );
		}

	}
}

void gdk_pixbuf_draw_circle_2 ( GdkPixbuf *pixbuf, guint32 pixel, gint xc, gint yc, gint r, gint fill )
{

	int y, x;

	if ( 0 )
	{
		for ( y = -r; y <= r; y++ )
		{
			for ( x = -r; x <= r; x++ )
			{
				if ( x*x + y*y <= r * r )
				{
					//setpixel(origin.x+x, origin.y+y);
					gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + x, yc + y );
				}
			}
		}

		return;
	}


	/* just the outline */
	for ( y = -r; y <= r; y++ )
	{
		for ( x = -r; x <= r; x++ )
		{

			g_print ( "y = %d x = %d\n", y, x );

			if ( x*x + y*y == r * r )
			{

				g_print ( "i= %d %d %d\n", y, x * x + y * y, r * r );

				//setpixel(origin.x+x, origin.y+y);
				gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + x, yc + y );
			}
		}
	}

}


void gdk_pixbuf_draw_circle ( GdkPixbuf *pixbuf, guint32 pixel, gint xc, gint yc, gint r, gint solid )
{
	int i, x, y;

	/* solid circle */
	if ( solid )
	{
		for ( y = -r; y <= r; y++ )
		{
			for ( x = -r; x <= r; x++ )
			{
				if ( x*x + y*y <= r * r )
				{
					//setpixel(origin.x+x, origin.y+y);
					gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + x, yc + y );
				}
			}
		}

		return;
	}

	/* outline only */
	i = r * r;

	for ( y = r ; y >= 0; y-- )
	{
		x = sqrt ( i - y * y );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + x, yc + y );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc - x, yc - y );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc - x, yc + y );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + x, yc - y );
	}

	for ( x = r ; x >= 0; x-- )
	{
		y = sqrt ( i - x * x );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + x, yc + y );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc - x, yc - y );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc - x, yc + y );
		gdk_pixbuf_set_pixel ( pixbuf, pixel, xc + x, yc - y );
	}

}
