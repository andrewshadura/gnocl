// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Boilerplate code was generated by http://burtonini.com/cgi/gobject.py

#include <gdk/gdkkeysyms.h>

#include "undo_entry.h"

G_DEFINE_TYPE ( GtkUndoEntry, gtk_undo_entry, GTK_TYPE_ENTRY )

/**
\brief
**/
static void
gtk_undo_entry_dispose ( GObject *object )
{
	GtkUndoEntry *uentry = GTK_UNDO_ENTRY ( object );

	if ( uentry->undo_manager_ )
	{
		g_object_unref ( G_OBJECT ( uentry->undo_manager_ ) );
		uentry->undo_manager_ = NULL;
	}

	G_OBJECT_CLASS ( gtk_undo_entry_parent_class )->dispose ( object );
}

/**
\brief
**/
void
gtk_undo_entry_undo ( GtkUndoEntry *uentry )
{
	if ( gtk_source_undo_manager_can_undo ( uentry->undo_manager_ ) )
		gtk_source_undo_manager_undo ( uentry->undo_manager_ );
}

/**
\brief
**/
void
gtk_undo_entry_redo ( GtkUndoEntry *uentry )
{
	if ( gtk_source_undo_manager_can_redo ( uentry->undo_manager_ ) )
		gtk_source_undo_manager_redo ( uentry->undo_manager_ );
}

/**
\brief
**/
static void
gtk_undo_entry_class_init ( GtkUndoEntryClass *klass )
{
	GObjectClass *object_class = G_OBJECT_CLASS ( klass );
	GtkBindingSet *binding_set;

	g_signal_new ( "undo",
				   G_TYPE_FROM_CLASS ( klass ),
				   G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
				   G_STRUCT_OFFSET ( GtkUndoEntryClass, undo ),
				   NULL,
				   NULL,
				   g_cclosure_marshal_VOID__VOID,
				   G_TYPE_NONE,
				   0 );
	g_signal_new ( "redo",
				   G_TYPE_FROM_CLASS ( klass ),
				   G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
				   G_STRUCT_OFFSET ( GtkUndoEntryClass, redo ),
				   NULL,
				   NULL,
				   g_cclosure_marshal_VOID__VOID,
				   G_TYPE_NONE,
				   0 );

	klass->undo = gtk_undo_entry_undo;
	klass->redo = gtk_undo_entry_redo;

	binding_set = gtk_binding_set_by_class ( klass );
	gtk_binding_entry_add_signal ( binding_set, GDK_z, GDK_CONTROL_MASK, "undo", 0 );
	gtk_binding_entry_add_signal ( binding_set, GDK_y, GDK_CONTROL_MASK, "redo", 0 );
	gtk_binding_entry_add_signal ( binding_set, GDK_z, GDK_CONTROL_MASK | GDK_SHIFT_MASK, "redo", 0 );
	gtk_binding_entry_add_signal ( binding_set, GDK_F14, 0, "undo", 0 );

	object_class->dispose = gtk_undo_entry_dispose;
}

/**
\brief
**/
static void
gtk_undo_entry_init ( GtkUndoEntry *self )
{
}

/**
\brief
**/
GtkWidget*
gtk_undo_entry_new ( GtkEntryBuffer *buffer )
{
	GtkWidget *ret = g_object_new ( GTK_TYPE_UNDO_ENTRY, "buffer", buffer, NULL );
	GTK_UNDO_ENTRY ( ret )->undo_manager_ = gtk_source_undo_manager_new ( GTK_ENTRY_BUFFER ( buffer ) );

	return ret;
}

